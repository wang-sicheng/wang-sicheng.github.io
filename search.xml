<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git基本操作</title>
    <url>/2020/03/04/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --list					<span class="comment"># 查看配置</span></span><br><span class="line">git config --global user.name wang-sicheng		<span class="comment"># 设置用户名</span></span><br><span class="line">git config --global user.email 247450210@qq.com		<span class="comment"># 设置邮箱</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote -v			<span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote add upstream url	<span class="comment"># 添加远程仓库</span></span><br></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch			<span class="comment"># 查看本地分支</span></span><br><span class="line">git branch -r			<span class="comment"># 查看远程分支</span></span><br><span class="line">git branch -a			<span class="comment"># 查看所有分支</span></span><br><span class="line">git branch new			<span class="comment"># 创建分支</span></span><br><span class="line">git branch -d dev		<span class="comment"># 删除分支</span></span><br><span class="line">git branch -m old new	<span class="comment"># 重命名分支</span></span><br><span class="line">git branch -d -r dev		<span class="comment"># 删除远程分支</span></span><br><span class="line"></span><br><span class="line">git checkout -b dev		<span class="comment"># 创建分支并切换</span></span><br><span class="line">git checkout dev		<span class="comment"># 切换分支</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h3><p>查看版本号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h3 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span>	</span><br><span class="line">git remote -v 			<span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote add upstream url 	<span class="comment"># 添加远程仓库</span></span><br><span class="line">git checkout -b newCheckout 	<span class="comment"># 创建分支</span></span><br><span class="line">git pull upstream master 	<span class="comment"># 拉取原仓库新代码到master分支</span></span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m “comment<span class="string">&quot;</span></span><br><span class="line"><span class="string">git push -u origin newCheckout 	# 将master推到自己的远程仓库</span></span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>修改git log</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure>
<p>修改上一次commit的注释</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit —amend -m “这是新的提交日志<span class="string">&quot; </span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git传输大文件——git lfs</title>
    <url>/2020/02/23/Git%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94git-lfs/</url>
    <content><![CDATA[<h4 id="Git-LFS（Git-Large-File-Storage）"><a href="#Git-LFS（Git-Large-File-Storage）" class="headerlink" title="Git LFS（Git Large File Storage）"></a>Git LFS（Git Large File Storage）</h4><p>Git将文件push至远程仓库时，要求单个文件小于100MB。如果单个文件大于100MB，则需要使用git lfs。</p>
<a id="more"></a>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>Linux</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s https:&#x2F;&#x2F;packagecloud.io&#x2F;install&#x2F;repositories&#x2F;github&#x2F;git-lfs&#x2F;script.deb.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo apt-get install git-lfs</span><br><span class="line"></span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>
<ul>
<li>Mac</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br><span class="line"></span><br><span class="line">brew install git-lfs</span><br><span class="line"></span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>追踪大文件（coding.png）（全部png文件）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git lfs track &quot;coding.png&quot;</span><br><span class="line"></span><br><span class="line">git lfs track &quot;*.png&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看正在追踪的文件模式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git lfs track</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提交大文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>克隆</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git lfs clone https:&#x2F;&#x2F;git.xxx.git</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Go使用匿名struct</title>
    <url>/2021/07/12/Go%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8Dstruct/</url>
    <content><![CDATA[<ul>
<li><p>var</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wang <span class="keyword">struct</span> &#123;Id <span class="keyword">int</span>; Name <span class="keyword">string</span>&#125;</span><br><span class="line">wang.Id = <span class="number">123</span></span><br><span class="line">wang.Name = <span class="string">&quot;schwang&quot;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>直接初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">json.Marshal(<span class="keyword">struct</span> &#123;Id <span class="keyword">int</span>; Name <span class="keyword">string</span>&#125;&#123;<span class="number">123</span>, <span class="string">&quot;schwang&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">json.Marshal(<span class="keyword">struct</span>&#123;</span><br><span class="line">  Id <span class="keyword">int</span></span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;&#123;<span class="number">123</span>, <span class="string">&quot;schwang&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Go反射reflect</title>
    <url>/2021/07/12/Go%E5%8F%8D%E5%B0%84reflect/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/itbsl/p/10551880.html">https://www.cnblogs.com/itbsl/p/10551880.html</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Go类型转换</title>
    <url>/2021/07/09/Go%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="常用类型转换"><a href="#常用类型转换" class="headerlink" title="常用类型转换"></a>常用类型转换</h2><table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>int</td>
<td>int, err := strconv.Atoi(string)</td>
<td>string := strconv.Itoa(int)</td>
</tr>
<tr>
<td>string</td>
<td>Int64</td>
<td>int64, err := strconv.ParseInt(string, 10, 64)</td>
<td>string := strconv.FormatInt(int64, 10)</td>
</tr>
<tr>
<td>string</td>
<td>float64</td>
<td>float64, err := strconv.ParseFloat(string, 64)</td>
<td>string := strconv.FormatFloat(float64, ‘E’, -1, 64)</td>
</tr>
<tr>
<td>string</td>
<td>[]byte</td>
<td>[]byte(string)</td>
<td>string(b)</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2020/03/11/HashMap/</url>
    <content><![CDATA[<h2 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h2><img src="/2020/03/11/HashMap/HashMap-put.png">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/21673805">https://zhuanlan.zhihu.com/p/21673805</a><br><a href="https://www.jianshu.com/p/5dbaa6707017">https://www.jianshu.com/p/5dbaa6707017</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo+Github</title>
    <url>/2019/09/08/Hexo-Github%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>1.注册一个域名（sicheng.wang）</p>
<p>2.添加解析</p>
<p>添加两个解析:<br>第一个作用于 <a href="http://www.sicheng.wang/">www.sicheng.wang</a> </p>
<img src="/2019/09/08/Hexo-Github%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/09/08/Hexo-Github%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/domin1.png" class title="解析">

<a id="more"></a>


<p>第二个作用于 sicheng.wang</p>
<img src="/2019/09/08/Hexo-Github%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/09/08/Hexo-Github%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/domin2.png" class title="解析">

<p>3.在source文件夹下创建CNAME文件，输入域名（sicheng.wang）</p>
<p>4.restart hexo</p>
<p>5.如果新域名还是不能用的话，一定要去核对域名信息，最好是与身份证信息完全一致。（通讯地址与身份证住址不一致会导致serverHold）</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2019/09/08/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="创建Hexo工程"><a href="#创建Hexo工程" class="headerlink" title="创建Hexo工程"></a>创建Hexo工程</h1><pre><code>$ hexo init [folder]
</code></pre>
<p>创建一个文件夹，使用hexo命令初始化为hexo工程目录。</p>
<h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><pre><code>$ hexo new [name]
</code></pre>
<p>会在/blog/source/_POST/下生成name.md文件。</p>
<a id="more"></a>
<h1 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h1><pre><code>$ hexo generate / $ hexo g
选项：
    -d, —deploy    文件生成后立即部署网站
    -w, —watch    监视文件变动
</code></pre>
<p>将md文件解析成HTML文件，存放至/blog/public/目录下。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><pre><code>$ hexo server / $ hexo s
选项：
-p, —port    重设端口
-s, —static   只使用静态文件
-l, —log        启动日记记录，使用覆盖记录格式
</code></pre>
<p>默认网址为：<a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>$ hexo deploy / $ hexo d
选项：
-g, —generate    部署之前生成静态文件
</code></pre>
<p>将文章部署至服务器。</p>
<h1 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h1><pre><code>$ hexo clean
</code></pre>
<p>清除缓存文件（db.json）和已生成的静态文件</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hive on MapReduce流程</title>
    <url>/2020/03/16/Hive-on-MapReduce%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<img src="/2020/03/16/Hive-on-MapReduce%E6%B5%81%E7%A8%8B/hive.png" width="100%">

]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA 设置server.port</title>
    <url>/2020/06/24/IDEA-%E6%8C%87%E5%AE%9Aserver-port/</url>
    <content><![CDATA[<h2 id="Edit-Configurations"><a href="#Edit-Configurations" class="headerlink" title="Edit Configurations"></a>Edit Configurations</h2><img src="/2020/06/24/IDEA-%E6%8C%87%E5%AE%9Aserver-port/edit.png">



<h2 id="Jar"><a href="#Jar" class="headerlink" title="Jar"></a>Jar</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=8000 -jar ./tailbaseSampling-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java线程的5种状态</title>
    <url>/2020/12/01/Java%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p><strong>1. 新建状态(New):</strong> 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</p>
<p><strong>2. 就绪状态(Runnable):</strong> 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</p>
<a id="more"></a>

<p><strong>3. 运行状态(Running):</strong> 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</p>
<p><strong>4. 阻塞状态(Blocked):</strong> 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p>
<ul>
<li>(01) 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>
<li>(02) 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>
<li>(03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
<p><strong>5. 死亡状态(Dead):</strong> 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<img src="/2020/12/01/Java%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81/thread.jpg">]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode11-盛水最多的容器</title>
    <url>/2020/03/22/LeetCode11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<a id="more"></a>

<img src="/2020/03/22/LeetCode11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/lc11.jpg">



<h2 id="提炼"><a href="#提炼" class="headerlink" title="提炼"></a>提炼</h2><p>给定数组arr，求出$min(arr[i], arr[j])*(j - i)$的最大值，其中i，j为数组下标，j &gt; i。可用暴力双循环或双指针解题。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxarea = <span class="number">0</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            maxarea = Math.max(maxarea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么只需要移动短边，便能遍历到最大面积值呢？其实，双指针法可以看做简化的暴力法。因为如果移动长边，那么在短边固定的情况下，所取得的面积都不可能比当前面积大，所以后续的比较都省去了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>Mac允许安装任何来源App</title>
    <url>/2020/05/20/Mac%E5%85%81%E8%AE%B8%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E6%9D%A5%E6%BA%90App/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>MacOS 10.12 <strong>系统偏好设置</strong>-&gt; <strong>安全性与隐私</strong> 中默认已经去除了允许安装任何来源App的选项，导致不是从AppStore中下载的软件无法正常安装。</p>
<img src="/2020/05/20/Mac%E5%85%81%E8%AE%B8%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E6%9D%A5%E6%BA%90App/before.png" width="40%">



<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><p>官方： control + 点击App</p>
</li>
<li><p>关闭 GateKeeper</p>
<p>  <code>sudo spctl --master-disable</code></p>
  <img src="/2020/05/20/Mac%E5%85%81%E8%AE%B8%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E6%9D%A5%E6%BA%90App/behind.png" width="40%">

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>​    <a href="https://support.apple.com/zh-cn/HT202491">https://support.apple.com/zh-cn/HT202491</a></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title>Neo4j基础</title>
    <url>/2020/02/23/Neo4j%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>Neo4j不同于传统的关系数据库管理系统，Neo4j是一个无架构的数据库。在开始添加数据之前，并不需要定义表和关系。Neo4j具有嵌入式、高性能、轻量级等优势。</p>
</blockquote>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>节点（Node）：包含属性</li>
<li>关系（Relationship）：包含属性</li>
</ul>
<a id="more"></a>

<p>节点与节点通过关系联系，关系是单向的。</p>
<img src="/2020/02/23/Neo4j%E5%9F%BA%E7%A1%80/02/23/Neo4j%E5%9F%BA%E7%A1%80/neo4j.png" class>


<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加节点</span><br><span class="line">create (x:Student&#123;id:1, age:14&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加属性</span><br><span class="line">match(x:Student&#123;id:1&#125;) set x.grade&#x3D;5 return x</span><br><span class="line">match(x:Student&#123;id:1&#125;) set x+&#x3D;&#123;grade:5&#125; return x</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对现有节点添加关系 </span><br><span class="line">match (x:Student&#123;id:1&#125;),(y:Teacher&#123;id:2&#125;) create (x)-[r:Teached&#123;name:&#39;English&#39;&#125;]-&gt;(y)</span><br><span class="line">match (x:Student),(y:Teacher) where x.id&#x3D;1 and y.id&#x3D;2 create (x)-[r:Teach&#123;name:&#39;English&#39;&#125;]-&gt;(y)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加节点并添加关系</span><br><span class="line">create (x:Student&#123;id:1&#125;)-[r:Teach&#123;name:&#39;English&#39;&#125;]-&gt;(y:Teacher&#123;id:2&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除单个节点</span><br><span class="line">match (x:Student&#123;id:1&#125;) delete x</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除单个节点及其所含关系</span><br><span class="line">match (x:Student) detach delete x</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除关系</span><br><span class="line">match (x:Teacher&#123;id:2&#125;)-[r:Teach&#123;name:&#39;English&#39;&#125;]-&gt;(y:Student&#123;id:1&#125;)  delete r</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除现有属性，添加新属性</span><br><span class="line">match(x:Student&#123;id:1&#125;) set x&#x3D;&#123;age:14, name:&#39;wsc&#39;&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改属性值</span><br><span class="line">match(x:Student&#123;id:1&#125;) set x.age&#x3D;15 return x</span><br></pre></td></tr></table></figure>

<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询节点</span><br><span class="line">match (x:Student&#123;id:1&#125;) return x</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 待补充</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Database</category>
      </categories>
  </entry>
  <entry>
    <title>NPM Error: gyp: No Xcode or CLT version detected</title>
    <url>/2020/02/22/NPM-Error-gyp-No-Xcode-or-CLT-version-detected/</url>
    <content><![CDATA[<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>mac的npm安装谷歌和百度的站点地图时，会出现 gyp: No Xcode or CLT version detected!</p>
<a id="more"></a>

<p>具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsc@mbp ⮀ ~/Hexo ⮀ npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm WARN deprecated core-js@1.2.7: core-js@&lt;3 is no longer maintained and not recommended <span class="keyword">for</span> usage due to the number of issues. Please, upgrade your dependencies to the actual version of core-js@3.</span><br><span class="line"></span><br><span class="line">&gt; fsevents@1.2.11 install /Users/wsc/Hexo/node_modules/hexo-generator-baidu-sitemap/node_modules/fsevents</span><br><span class="line">&gt; node-gyp rebuild</span><br><span class="line"></span><br><span class="line">No receipt <span class="keyword">for</span> <span class="string">&#x27;com.apple.pkg.CLTools_Executables&#x27;</span> found at <span class="string">&#x27;/&#x27;</span>.</span><br><span class="line"></span><br><span class="line">No receipt <span class="keyword">for</span> <span class="string">&#x27;com.apple.pkg.DeveloperToolsCLILeo&#x27;</span> found at <span class="string">&#x27;/&#x27;</span>.</span><br><span class="line"></span><br><span class="line">No receipt <span class="keyword">for</span> <span class="string">&#x27;com.apple.pkg.DeveloperToolsCLI&#x27;</span> found at <span class="string">&#x27;/&#x27;</span>.</span><br><span class="line"></span><br><span class="line">gyp: No Xcode or CLT version detected!</span><br><span class="line">gyp ERR! configure error</span><br><span class="line">gyp ERR! stack Error: `gyp` failed with <span class="built_in">exit</span> code: 1</span><br><span class="line">gyp ERR! stack     at ChildProcess.onCpExit (/usr/<span class="built_in">local</span>/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16)</span><br><span class="line">gyp ERR! stack     at ChildProcess.emit (events.js:321:20)</span><br><span class="line">gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12)</span><br><span class="line">gyp ERR! System Darwin 19.3.0</span><br><span class="line">gyp ERR! <span class="built_in">command</span> <span class="string">&quot;/usr/local/Cellar/node/13.6.0/bin/node&quot;</span> <span class="string">&quot;/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot;</span> <span class="string">&quot;rebuild&quot;</span></span><br><span class="line">gyp ERR! cwd /Users/wsc/Hexo/node_modules/hexo-generator-baidu-sitemap/node_modules/fsevents</span><br><span class="line">gyp ERR! node -v v13.6.0</span><br><span class="line">gyp ERR! node-gyp -v v5.0.5</span><br><span class="line">gyp ERR! not ok</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 (node_modules/hexo-generator-baidu-sitemap/node_modules/fsevents):</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 install: `node-gyp rebuild`</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: Exit status 1</span><br></pre></td></tr></table></figure>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm -rf $(xcode-select -print-path)</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<h5 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h5><blockquote>
<p><a href="https://www.cnblogs.com/zhennann/p/12272058.html">https://www.cnblogs.com/zhennann/p/12272058.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/schnerd/d3-scale-cluster/issues/7">https://github.com/schnerd/d3-scale-cluster/issues/7</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/nodejs/node-gyp/blob/master/macOS_Catalina.md">https://github.com/nodejs/node-gyp/blob/master/macOS_Catalina.md</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Redis一致性Hash算法</title>
    <url>/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当缓存数据量达到一定程度时，需要使用Redis集群来提高读写性能，可采用两种方式：</p>
<ul>
<li><p>读写分离（主从复制）</p>
</li>
<li><p>分库分表</p>
  <img src="/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/copy.png">

  <div align="center"> 主从复制全量同步 </div>

</li>
</ul>
<a id="more"></a>

<p>通常，我们将Redis服务器分成两两一组，每组一个主节点和一个从节点，主节点负责处理写命令，从节点负责处理读命令。每组节点缓存不同的数据（分库分表）。假设若干Redis服务器分成了n组，如果不采用任何算法的话，那么每次查询数据都需要遍历n组Redis服务器。最简单的想法是采用Hash算法（类似Java的HashMap，先Hash再对长度取余），但是这在有Redis服务器下线或上线时会出现大量数据失效的情况，所以出现了Hash环一致性算法。</p>
<img src="/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/hash_ring.jpg">

<img src="/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/node.jpg">

<img src="/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/object.jpg">

<img src="/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/down.jpg">

<img src="/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/up.jpg">

<img src="/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/tilt.jpg">

<img src="/2020/03/31/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/virtual.jpg">



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/wlccomeon/article/details/86553831">https://blog.csdn.net/wlccomeon/article/details/86553831</a></p>
<p><a href="https://juejin.im/post/5b16148a518825136137c8db">https://juejin.im/post/5b16148a518825136137c8db</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ客户端分析</title>
    <url>/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="客户端-client"><a href="#客户端-client" class="headerlink" title="客户端(client)"></a>客户端(client)</h1><p>RocketMQ的客户端（client）由Producer和Consumer两部分组成，其中Producer负责生产消息，Consumer负责消费消息。在实际应用场景中，Producer一般是业务系统，Consumer一般是后台系统。拿电商模型举例，会员系统和订单系统是Producer，负责发布消息；短信系统和配送系统是Consumer，它们订阅相应Topic，消费对应信息，如下图所示。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/model.jpg" class>
<a id="more"></a>

<h3 id="1-消息生产者（Producer）"><a href="#1-消息生产者（Producer）" class="headerlink" title="1 消息生产者（Producer）"></a>1 消息生产者（Producer）</h3><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<h4 id="（1）-同步发送"><a href="#（1）-同步发送" class="headerlink" title="（1）    同步发送"></a>（1）    同步发送</h4><p>调用：DefaultMQProducer的send方法</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/sendSyncCall.jpg" class>
<p>Producer发送出消息后，必须在Broker发回响应后才能发送下一个消息。这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/sendSync.png" class>
<h4 id="（2）-异步发送"><a href="#（2）-异步发送" class="headerlink" title="（2）    异步发送"></a>（2）    异步发送</h4><p>调用：DefaultMQProducer的send方法，由参数SendCallback作为回调函数异步处理Broker响应。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/sendAsyncCall.jpg" class>
<p>Producer发送出消息后，不等待Broker发回响应即可接着发送下一个消息。异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/sendAsync.png" class>
<h4 id="（3）-单项发送"><a href="#（3）-单项发送" class="headerlink" title="（3）    单项发送"></a>（3）    单项发送</h4><p>调用：DefaultMQProducer的sendOneway方法</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/sendOnewayCall.jpg" class>
<p>Producer只负责发送消息，不接受Broker的响应。这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/sendOneway.png" class>
<p>上述三种发送模式实现：DefaultMQProducerImpl的sendKernelImpl方法，由参数CommunitionMode指定发送模式。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/sendImpl.jpg" class>
<h3 id="2-消息消费者（Consumer）"><a href="#2-消息消费者（Consumer）" class="headerlink" title="2 消息消费者（Consumer）"></a>2 消息消费者（Consumer）</h3><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/pullAndpush.png" class>
<h4 id="（1）-拉取式消费"><a href="#（1）-拉取式消费" class="headerlink" title="（1）    拉取式消费"></a>（1）    拉取式消费</h4><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>
<h5 id="1-gt-同步拉取"><a href="#1-gt-同步拉取" class="headerlink" title="1&gt;    同步拉取"></a>1&gt;    同步拉取</h5><p>调用：DefaultMQPullConsumer的pullBlockIfNotFound方法。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/pullSyncCall.jpg" class>
<p>实现：DefaultMQPullConsumerImpl的pullSyncImpl方法。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/pullSyncImpl.jpg" class>
<h5 id="2-gt-异步拉取"><a href="#2-gt-异步拉取" class="headerlink" title="2&gt;    异步拉取"></a>2&gt;    异步拉取</h5><p>调用：DefaultMQPullConsumer的pullBlockIfNotFound方法，由参数PullCallback作为回调函数异步处理Broker响应。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/pullAsyncCall.jpg" class>
<p>实现：DefaultMQPullConsumerImpl的pullAsyncImpl方法，由参数PullCallback作为回调函数异步处理Broker响应。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/pullAsyncImpl.jpg" class>
<h4 id="（2）-推动式消费"><a href="#（2）-推动式消费" class="headerlink" title="（2）    推动式消费"></a>（2）    推动式消费</h4><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<img src="/2019/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/09/24/RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E6%9E%90/pushConsumerListener.jpg" class>
<p>push为被动消费类型，pull为主动消费类型，push方式最终还是会从broker中pull消息。不同于pull的是，push首先要注册消费监听器，当监听器处触发后才开始消费消息，所以被称为“被动”消费。故最终实现仍为上述的DefaultMQPullConsumerImpl的pullSyncImpl方法和pullAsyncImpl方法。</p>
]]></content>
  </entry>
  <entry>
    <title>Spark RDD</title>
    <url>/2020/03/06/Spark-RDD/</url>
    <content><![CDATA[<img src="/2020/03/06/Spark-RDD/rdd结构.jpg" width="50%">
<a id="more"></a>
<img src="/2020/03/06/Spark-RDD/RDD空间.png" width="50%">

<img src="/2020/03/06/Spark-RDD/03/06/Spark-RDD/wordcount.png" class>
<img src="/2020/03/06/Spark-RDD/03/06/Spark-RDD/spark%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpeg" class>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>Spring常用注解</title>
    <url>/2020/10/05/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>使用注解之前要开启自动扫描功能，其中base-package为需要扫描的包(含子包)。</p>
<p><code>&lt;context:component-scan base-package=&quot;org.example.spring&quot;/&gt; </code></p>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>​    @Autowired注解要去寻找的是一个Bean，其作用是为了消除getter/setter方法与bean属性中的property。当Spring发现@Autowired注解时，将自动在代码上下文中找到和其匹配（默认是类型匹配）的Bean，并自动注入到相应的地方去。配合@Qualifier注解来指定Bean的名称。</p>
<a id="more"></a>

<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul>
<li>@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配</li>
<li>指定了name或者type则根据指定的类型去匹配bean</li>
<li>指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错</li>
</ul>
<p>@Autowired和@Resource的区别：</p>
<ul>
<li>@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配</li>
<li>@Autowired是Spring的注解，@Resource是J2EE的注解，建议使用@Resource注解，以减少代码和Spring之间的耦合。</li>
</ul>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><ul>
<li><p>用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象，分发处理器会扫描使用该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。</p>
</li>
<li><p>@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是处理请求的处理器。</p>
</li>
</ul>
<h4 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h4><ul>
<li>声明目标类是一个Bean，其他的类可以使用@Autowired将其作为一个成员变量自动注入。</li>
<li>Bean中的id为类名且首字母小写。</li>
</ul>
<h4 id="Test"><a href="#Test" class="headerlink" title="@Test"></a>@Test</h4><p>​    通过org.junit.Test中的API的类反射生成测试类，然后调用@Test注解的方法。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。<br>@Scope注解 作用域<br>@Lazy(true) 表示延迟初始化<br>@Service用于标注业务层组件<br>@Controller用于标注控制层组件（如struts中的action）<br>@Repository用于标注数据访问组件，即DAO组件。<br>@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。<br>@Scope用于指定scope作用域的（用在类上）<br>@PostConstruct用于指定初始化方法（用在方法上）<br>@PreDestory用于指定销毁方法（用在方法上）<br>@DependsOn：定义Bean初始化及销毁时的顺序<br>@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常<br>@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：<br>@Autowired @Qualifier(“personDaoBean”) 存在多个实例配合使用<br>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。<br>@PostConstruct 初始化注解<br>@PreDestroy 摧毁注解 默认 单例 启动就加载<br>@Async异步方法调用</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring配置</title>
    <url>/2020/11/01/Spring%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="lt-context-annotation-config-gt"><a href="#lt-context-annotation-config-gt" class="headerlink" title="&lt;context:annotation-config /&gt;"></a>&lt;context:annotation-config /&gt;</h4><p>用于激活已经在Spring容器里注册过的bean上面的注解，即向Spring注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AutowiredAnnotationBeanPostProcessor（识别@Autowired）</span><br><span class="line">CommonAnnotationBeanPostProcessor（识别@Resource、@PostConstruct、@PreDestroy）</span><br><span class="line">PersistenceAnnotationBeanPostProcessor（识别@PersistenceContext）</span><br><span class="line">RequiredAnnotationBeanPostProcessor（识别@Required）</span><br></pre></td></tr></table></figure>
<p>想要使用上述注解，必须声明对应Processor的bean。传统注册方式为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.CommonAnnotationBeanPostProcessor&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.PersistenceAnnotationBeanPostProcessor&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>
<p>现在使用 <code>&lt;context:annotation-config/&gt; </code> 即可。</p>
<h4 id="lt-context-component-scan-base-package-”XX-XX”-gt"><a href="#lt-context-component-scan-base-package-”XX-XX”-gt" class="headerlink" title="&lt;context:component-scan base-package=”XX.XX”/&gt;"></a>&lt;context:component-scan base-package=”XX.XX”/&gt;</h4><p>除了具有 <code>&lt;context:annotation-config/&gt;</code> 的功能之外，还具有自动将带有@component,@service,@Repository等注解的对象注册到Spring容器中的功能。</p>
<p>当 <code>&lt;context:annotation-config/&gt;</code> 和 <code>&lt;context:component-scan&gt;</code> 同时存在时，前者会被忽略。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Unix 5种I/O模型</title>
    <url>/2020/04/07/Unix-5%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>阻塞：请求不能立即得到应答，需要等待。<br>非阻塞：请求立即得到应答，不需要等待。<br>同步I/O：同步I/O操作引起请求进程阻塞，直到I/O操作完成。<br>异步I/O：异步I/O操作不引起请求进程阻塞。</p>
<a id="more"></a>

<h2 id="Unix-I-O模型"><a href="#Unix-I-O模型" class="headerlink" title="Unix I/O模型"></a>Unix I/O模型</h2><img src="/2020/04/07/Unix-5%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/block.png" width="80%">

<div align="center"> 阻塞I/O </div>

<img src="/2020/04/07/Unix-5%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/nonblock.png" width="80%">

<div align="center"> 非阻塞I/O </div>

<img src="/2020/04/07/Unix-5%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/multiplexing.png" width="60%">

<div align="center"> I/O复用 </div>

<img src="/2020/04/07/Unix-5%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/signal.png" width="80%">

<div align="center"> 信号驱动I/O </div>

<img src="/2020/04/07/Unix-5%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/aio.png" width="80%">

<div align="center"> 异步I/O </div>

<img src="/2020/04/07/Unix-5%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/compare.png" width="80%">

<div align="center"> 比较 </div>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cd90e2cf265da0380438de7">https://juejin.im/post/5cd90e2cf265da0380438de7</a></p>
]]></content>
  </entry>
  <entry>
    <title>crontab</title>
    <url>/2020/02/20/crontab/</url>
    <content><![CDATA[<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>crontab是用来定期周期性执行程序的命令。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>crontab [-u user] {-l | -r | -e | file}</p>
<a id="more"></a>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>-u    指定用户（默认为当前用户）<br>-e    编辑时程表<br>-r    删除当前的时程表<br>-l    列出当前的时程表</p>
<h4 id="格式说明"><a href="#格式说明" class="headerlink" title="格式说明"></a>格式说明</h4><blockquote>
<p>a  b  c  d  e  program</p>
</blockquote>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b    c    d    e    p</span><br><span class="line">-    -    -    -    -    -</span><br><span class="line">|    |    |    |    |    |</span><br><span class="line">|    |    |    |    |    +--- 要执行的程序</span><br><span class="line">|    |    |    |    +-------- 星期中星期几 (0 - 6) (星期天为0)</span><br><span class="line">|    |    |    +------------- 月份 (1 - 12)</span><br><span class="line">|    |    +------------------ 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +----------------------- 小时 (0 - 23)</span><br><span class="line">+---------------------------- 分钟 (0 - 59)</span><br></pre></td></tr></table></figure>
<ul>
<li><p> 当a为*时，表示每分钟都要执行一次程序</p>
</li>
<li><p> 当a为A-B时，表示从第A分钟到第B分钟都要执行一次程序</p>
</li>
<li><p> 当a为*/n时，表示每隔n分钟执行一次程序</p>
</li>
<li><p>当a为A,B,C,…时，表示第A,B,C,…分钟执行一次程序</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>注意到上述规则描述的最小时间单位是分钟，那么想每隔数秒执行一次程序该如何写呢？<br>每隔10秒执行一次程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * &#x2F;bin&#x2F;example.sh	</span><br><span class="line">* * * * * sleep 10; &#x2F;bin&#x2F;example.sh</span><br><span class="line">* * * * * sleep 20; &#x2F;bin&#x2F;example.sh</span><br><span class="line">* * * * * sleep 30; &#x2F;bin&#x2F;example.sh</span><br><span class="line">* * * * * sleep 40; &#x2F;bin&#x2F;example.sh</span><br><span class="line">* * * * * sleep 50; &#x2F;bin&#x2F;example.sh</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>curl发送POST请求</title>
    <url>/2021/05/23/curl%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -H 请求头 -d 请求体 -X POST URL</span><br></pre></td></tr></table></figure>


<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>无请求体（参数编码在url里，省去 -H “application/x-www-form-urlencoded”）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&#x27;name=wsc&#x27;</span> http://localhost:8848/api/name</span><br></pre></td></tr></table></figure>
<ul>
<li>请求体内容为json</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;wsc&quot;, &quot;age&quot;:24&#125;&#x27;</span> http://localhost:8848/api/user</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>intelliJ隐藏INFO信息</title>
    <url>/2020/02/15/intellij%E9%9A%90%E8%97%8FINFO/</url>
    <content><![CDATA[<p>在maven项目下的resources目录下新增log4j.properties文件，填写如下内容。log4j.rootCategory=ERROR代表显示级别为ERROR。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootCategory&#x3D;ERROR, console</span><br><span class="line">log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.target&#x3D;System.err</span><br><span class="line">log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern&#x3D;%d&#123;yy&#x2F;MM&#x2F;dd HH:mm:ss&#125; %p %c&#123;1&#125;: %m%n</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>jar中没有主清单属性</title>
    <url>/2020/07/10/jar%E4%B8%AD%E6%B2%A1%E6%9C%89%E4%B8%BB%E6%B8%85%E5%8D%95%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="Maven-项目编译运行打包正常，运行jar出现错误"><a href="#Maven-项目编译运行打包正常，运行jar出现错误" class="headerlink" title="Maven 项目编译运行打包正常，运行jar出现错误"></a>Maven 项目编译运行打包正常，运行jar出现错误</h3><img src="/2020/07/10/jar%E4%B8%AD%E6%B2%A1%E6%9C%89%E4%B8%BB%E6%B8%85%E5%8D%95%E5%B1%9E%E6%80%A7/jar.png">



<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>程序找不到入口函数 mainClass</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在 pom.xml 中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.example.Calculate<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后重新 mvn clean package</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>maven更换源</title>
    <url>/2020/02/11/maven%E6%9B%B4%E6%8D%A2%E6%BA%90/</url>
    <content><![CDATA[<p>在setting.xml的&lt;mirrors&gt;标签中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>uk<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://uk.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>internal nexus repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/03/12/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树形态树"><a href="#二叉树形态树" class="headerlink" title="二叉树形态树"></a>二叉树形态树</h2><p>求n个结点的二叉树有多少种形态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(n))</span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            count += numTrees(i) * numTrees(n - i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(n, count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(TreeDepth(root.left), TreeDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 非递归 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pre.length;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> idx = findIndex(in, pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, idx + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, idx));</span><br><span class="line">        root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, idx + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, idx + <span class="number">1</span>, in.length));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[] in, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">         </span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        TreeNode tmp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = tmp;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1.val == root2.val &amp;&amp; isMirror(root1.left, root2.right) &amp;&amp; isMirror(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node1 = queue.poll();</span><br><span class="line">            TreeNode node2 = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="和为K的路径"><a href="#和为K的路径" class="headerlink" title="和为K的路径"></a>和为K的路径</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        list.add(root.val);</span><br><span class="line">        </span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line">        </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（空树不是任意一个树的子结构）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSub(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubTree(root1.left, root2.left) &amp;&amp; isSubTree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = seq.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(--n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(seq[i] &lt; seq[n])</span><br><span class="line">                i++;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">while</span>(seq[i] &gt; seq[n])</span><br><span class="line">                i++;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span>(i != n)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span></span><br><span class="line">            &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪枝</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 如果输入的是平衡二叉树，返回深度；否则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode tar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tar.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode p = tar.right;</span><br><span class="line">            <span class="keyword">while</span>(p.left != <span class="keyword">null</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tar.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tar.next.left == tar)&#123;</span><br><span class="line">            <span class="keyword">return</span> tar.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            TreeLinkNode q = tar.next;</span><br><span class="line">            <span class="keyword">while</span>(q.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.next.left == q)</span><br><span class="line">                    <span class="keyword">return</span> q.next;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二叉搜索树第K小节点"><a href="#二叉搜索树第K小节点" class="headerlink" title="二叉搜索树第K小节点"></a>二叉搜索树第K小节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = KthNode(root.left, k);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        </span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        node = KthNode(root.right, k);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="有序数组转二叉平衡树"><a href="#有序数组转二叉平衡树" class="headerlink" title="有序数组转二叉平衡树"></a>有序数组转二叉平衡树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 选择左中节点做根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (high + low) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 选择右中节点做根节点</span></span><br><span class="line">        <span class="comment">// if ((high + low) % 2 == 1) &#123;</span></span><br><span class="line">        <span class="comment">//     mid++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 随机</span></span><br><span class="line">      	<span class="comment">// if ((high + low) % 2 == 1) &#123;</span></span><br><span class="line">        <span class="comment">//     mid += rand.nextInt(2);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">        root.left = helper(arr, low, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树右视图</title>
    <url>/2019/09/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="二叉树右视图"><a href="#二叉树右视图" class="headerlink" title="二叉树右视图"></a>二叉树右视图</h1><blockquote>
<p><a href="https://leetcode.com/problems/binary-tree-right-side-view/">https://leetcode.com/problems/binary-tree-right-side-view/</a></p>
</blockquote>
<p>题意：给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<pre><code>Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:
   1            &lt;---
  /   \
2     3         &lt;---
  \     \
    5     4       &lt;---
</code></pre>
<a id="more"></a>

<p>我的解题思路是利用的二叉树的层序遍历，每层只记录最后一个节点，即每层的最右节点。具体实现是利用队列存储节点，在处理每层之前先记录当前队列的长度，也就是该层的长度，避免当前层节点与下一层节点混淆，同时也能确定当前层最后一个节点的位置。因为只是对二叉树进行了层序遍历，所以时间复杂度为O(n)，空间复杂度为O(n)。代码见1-1。</p>
<p>本题还可以用深度优先搜索解答。在该解法中，总是优先访问右子树，并同时记录当前访问节点的深度，以判断该节点是否为每层的最右节点。具体实现是利用两个栈和一个哈希映射表，一个栈用来记录节点，另一个栈用来记录对应节点的深度，哈希映射表存储每层的深度的最右节点，以避免在访问到左子树时，将节点错误判断为最右节点。该解法同样是遍历了所有节点，所以时间复杂度为O(n)，空间复杂度为O(n)。代码见1-2。</p>
<p>二叉树的题目往往都可以用递归来解答，本题也不例外。其实原理和上述利用双栈解题一样，都是优先访问右子树，并利用深度结果列表的数量关系来判断当前节点是否为最右节点。时间复杂度为O(n)，空间复杂度为O(n)。代码见1-3。</p>
<p>总的来说，还是方法一最简单而且高效，只需要一个队列。方法二需要双栈和哈希映射表，方法三可能因为二叉树的深度过大而爆栈。</p>
<p>1-1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i == size - <span class="number">1</span>)</span><br><span class="line">                    ans.add(root.val);</span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.left);</span><br><span class="line">                <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1-2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack();</span><br><span class="line">        Stack&lt;Integer&gt; depthStack = <span class="keyword">new</span> Stack();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!nodeStack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = nodeStack.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = depthStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                maxDepth = Math.max(maxDepth, depth);</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(depth))&#123;</span><br><span class="line">                    map.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth + <span class="number">1</span>);</span><br><span class="line">                depthStack.push(depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> depth = <span class="number">1</span>; depth &lt;= maxDepth; depth++)</span><br><span class="line">            ans.add(map.get(depth));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1-3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        dfs(root, ans, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode cur, List&lt;Integer&gt; ans, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(depth == ans.size())</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line"></span><br><span class="line">        dfs(cur.right, ans, depth + <span class="number">1</span>);</span><br><span class="line">        dfs(cur.left, ans, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>从输入URL到显示结果</title>
    <url>/2020/02/26/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<ol>
<li><p>查询浏览器的DNS缓存和操作系统地DNS缓存</p>
</li>
<li><p>将域名发送至本地DNS服务器，本地DNS服务器查询DNS缓存（递归查询）</p>
</li>
</ol>
<a id="more"></a>

<ol start="3">
<li><p>本地DNS服务器代浏览器进行迭代查询</p>
<ul>
<li>向根域名服务器发送请求，得到顶级域名服务器IP地址</li>
<li>向顶级域名服务器发送请求，得到权限域名服务器IP地址</li>
<li>向权限域名服务器发送请求，得到目标域名IP地址</li>
</ul>
</li>
<li><p>本地域名服务器将IP地址缓存后，返回给操作系统，操作系统也将IP地址缓存后，返回给浏览器</p>
</li>
<li><p>浏览器以该IP地址为目标地址发送Http请求，采用HTTP协议将请求封装为报文</p>
</li>
<li><p>传输层：采用TCP协议将报文封装为报文段</p>
</li>
<li><p>网络层：采用IP协议将报文段封装为数据报，此时采用ARP协议将目标IP地址封装为ARP请求，并广播到局域网所有主机上，得到目标主机的MAC地址</p>
</li>
</ol>
<ol start="8">
<li><p>数据链路层：将数据报封装成MAC帧。</p>
</li>
<li><p>服务器接收到MAC帧后层层解封，将请求传递至对应HTTP应用。服务器将相应以同样地方式返回给浏览器。</p>
</li>
<li><p>浏览器渲染后呈现给用户</p>
</li>
</ol>
<p>待完善</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2019/09/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="Single-Number-I"><a href="#Single-Number-I" class="headerlink" title="Single Number I"></a>Single Number I</h1><blockquote>
<p><a href="https://leetcode.com/problems/single-number/">https://leetcode.com/problems/single-number/</a></p>
</blockquote>
<p>题意：一个数组中只有一个出现一次的数字，其余所有数字均出现两次，我们需要找出这个出现一次的数字。</p>
<pre><code>Example:
Input: [4, 1, 2, 1, 2]
Output:4
</code></pre>
<a id="more"></a>
<p>按照正常的思路，遍历数组并用列表来存储，如果数字之前出现过，也就是已经存储在列表中了，这代表该数字出现了两次，应该删掉它。遍历结束后，列表里仅剩的数字就是题目要找的数字。该解法的时间复杂度为O(n2)。因为遍历数组需要O(n)时间，在遍历每一个元素时，需要在列表中查找重复元素，也就是遍历列表，同样花费O(n)，故总共花费O(n2)。空间复杂度为O(n)。按照最坏的情况计算，当所有非重复元素都集中在数组的前半部时，所需空间最大，所有非重复元素个数为 n / 2 + 1，故空间复杂度为O(n)。<br>    本题可以使用位运算：异或（XOR）。因为异或运算有如下性质：</p>
<pre><code>(1.1)    a xor a = 0        
(1.2)    a xor 0 = a            
(1.3)    a xor b = b xor a        
</code></pre>
<p>（1.1）保证了两个相同的数字进行异或后结果为0。（1.2）使得出现一次的数字与0异或后仍然为本身。（1.3）表示数字间的异或顺序不影响结果。所以异或的性质完全契合这道题目，我们将数组中的所有数字相异或，得到的最终结果即为答案。</p>
<pre><code>举例：[2, 3, 1, 2, 1]
2 xor 3 xor 1 xor 2 xor 1 = 1 xor 1 xor 2 xor 2 xor 3 = 0 xor 0 xor 3 = 3
</code></pre>
<h1 id="Single-Number-III"><a href="#Single-Number-III" class="headerlink" title="Single Number III"></a>Single Number III</h1><blockquote>
<p><a href="https://leetcode.com/problems/single-number-iii/">https://leetcode.com/problems/single-number-iii/</a></p>
</blockquote>
<p>题意：一个数组中只有两个出现一次的数字，其余所有数字都出现两次，我们需要找出这两个出现一次的数字。题目要求算法为线性时间复杂度，即O(n)。</p>
<pre><code>Example:
Input: [1, 2, 1, 3, 6, 2, 5, 4, 6, 4]
Output:[3, 5]
</code></pre>
<p>很多O(n)时间复杂度的算法都利用了以空间换时间的思想，但是本题并没有限制数字的范围，那么就认为范围是 -2^31 ~ 2^31-1，显然，不可能用数组去存储已经遍历的数字，我用的是查询时间为O(1) （不考虑冲突）的哈希集合。算法步骤：遍历数组，如果集合含有该数字，那么删去它，如果不含有则将其添加进去，遍历结束后集合内仅剩的两个数字即为所需结果。</p>
<p>本题同样可以使用位运算。如果将全部数字进行异或运算，那么得到仅仅是两个目标数字的异或结果，并不能将其拆分开。倘若能将数字分成两组，两组数字都符合Single Number I题中的描述，那么我们就能套用前面的算法。分组的关键在于两点：</p>
<ol>
<li>   两个目标数字要分在不同的组。</li>
<li>   相同数字要成对分在相同的组。</li>
</ol>
<p>如将上述Input分组成 <code>[1, 1, 2, 2, 3]</code> 和 <code>[4, 4, 6, 6, 5]</code>，然后即可用I题中算法求得答案。<br>我们目前只能得到两个目标数字的异或结果，考虑到异或按位运算的性质——两个输入相同时为0，不同则为1。那么我们从异或结果的二进制中找到某一位为1，这代表两个目标数字的二进制在这一位不相同（一个为0，一个为1），这样我们可以用这一位对数字进行按位与即可区分两个目标数字。其他数字也同理，因为两个相等的数字的二进制在某一位上同为0或同为1，故也能通过与运算将成对的数字分入一组。</p>
<h1 id="Single-Number-II"><a href="#Single-Number-II" class="headerlink" title="Single Number II"></a>Single Number II</h1><blockquote>
<p><a href="https://leetcode.com/problems/single-number-ii/">https://leetcode.com/problems/single-number-ii/</a></p>
</blockquote>
<p>题意：一个数组中只有一个出现一次的数字，其余所有数字均出现三次，我们需要找出这个出现一次的数字。<br>从数学角度看，<code>c =[ 3 * (a + b + c) – (a + a + a + b + b + b + c) ] / 2</code>，故我们需要求得不同数字之和，所以采用哈希集合对数组进行遍历求和，然后利用数学公式即可求得答案。利用HashMap记录每个数字出现的次数，最终只出现一次的数字即为答案。两种方法时间复杂度和空间复杂度均为O(n)。<br>由前面两道题可知，我们利用了异或的性质：</p>
<pre><code>x ^ 0 = x    
x ^ x = 0
</code></pre>
<p>使得一个数出现一次结果为本身，出现两次则能抵消变为0。故本题也可以采用同样的方法，即当一个数出现一次结果为本身，出现三次则能抵消为0，不过因为达到了三次，需要两个数字来指示，过程为：00 – 01 – 10 – 00，例如用once、twice来数字出现的次数，对每一个数字num：</p>
<pre><code>once = (once ^ num) &amp; ~twice;
twice = (twice ^ num) &amp; ~once;
</code></pre>
<p>次数记录情况表</p>
<table>
<thead>
<tr>
<th align="center">num出现次数</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">once</td>
<td align="center">num</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">twice</td>
<td align="center">0</td>
<td align="center">num</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>遍历结束后结果即为once。时间复杂为O(n)，空间复杂度为O(1)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Single Number I:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            ans ^= num;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Single Number III:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            xor ^= num;</span><br><span class="line">        <span class="keyword">int</span> diff = xor &amp; -xor;</span><br><span class="line">        <span class="keyword">int</span>[] ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; diff) == <span class="number">0</span>)</span><br><span class="line">                ans[<span class="number">0</span>] ^= num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans[<span class="number">1</span>] ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Single Number II:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> once = <span class="number">0</span>, twice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            once = (once ^ n) &amp; ~twice;</span><br><span class="line">            twice = (twice ^ n) &amp; ~once; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> once;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2019/09/13/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求数组的全排列</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    List&lt;Integer&gt; line = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    line.add(nums[<span class="number">0</span>]);</span><br><span class="line">    ans.add(line);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; new_ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(List&lt;Integer&gt; l : ans)&#123;</span><br><span class="line">                List&lt;Integer&gt; new_line = <span class="keyword">new</span> LinkedList(l);</span><br><span class="line">                new_line.add(j, nums[i]);</span><br><span class="line">                new_ans.add(new_line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = new_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// with boolean[] visited</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.size() == nums.length)</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backtrack(list, visited, nums);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// without boolean[] visited</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.size() == nums.length)</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.contains(nums[i]))</span><br><span class="line">                <span class="keyword">continue</span>;       </span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backtrack(list, nums);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// duplicated arrry</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.size() == nums.length)</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">        backtrack(list, visited, nums);</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        PermutationHelper(str.toCharArray(), <span class="number">0</span>, ans);</span><br><span class="line">        Collections.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">PermutationHelper</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, ArrayList&lt;String&gt; ans)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(i == arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">             ans.add(String.valueOf(arr));</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; arr.length; j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(j == i || !set.contains(arr[j]))&#123;</span><br><span class="line">                     set.add(arr[j]);</span><br><span class="line">                     swap(arr, i, j);</span><br><span class="line">                     PermutationHelper(arr, i + <span class="number">1</span>, ans);</span><br><span class="line">                     swap(arr, j, i);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>内存溢出和内存泄漏</title>
    <url>/2020/02/29/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h4 id="内存溢出和内存泄漏的区别"><a href="#内存溢出和内存泄漏的区别" class="headerlink" title="内存溢出和内存泄漏的区别"></a>内存溢出和内存泄漏的区别</h4><p>内存溢出（Out Of Memory）是指当系统剩余内存空间无法满足申请的内存空间所出现的问题。</p>
<p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存未释放或无法释放，造成系统内存的浪费。</p>
<a id="more"></a>

<h4 id="内存溢出的常见原因"><a href="#内存溢出的常见原因" class="headerlink" title="内存溢出的常见原因"></a>内存溢出的常见原因</h4><ol>
<li>加载的数据量过大。如查询数据库时，一次性获得全部数据，尽量采用分页的方式查询。</li>
<li>代码中有死循环或递归调用。</li>
<li>循环产生新对象实例。</li>
<li>集合类对象使用完后未清除，GC无法回收。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>初次使用树莓派</title>
    <url>/2019/09/08/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    <content><![CDATA[<h1 id="组装外壳"><a href="#组装外壳" class="headerlink" title="组装外壳"></a>组装外壳</h1><ol>
<li><p>风扇<br>风扇是通过排线连接raspberry的，并且无法通过软件来开关，由于风扇声音太大，放在宿舍影响休息，所以风扇被当成了一个装饰品。</p>
</li>
<li><p>屏幕<br>原以为屏幕是必需品，结果装上3.5英寸屏幕后（和iphone4屏幕一样大），才发现屏幕太小了，而且响应速度也很令人捉急。所以，对命令行熟悉的同学最好不要上屏幕。其实还有一个更好的办法，见本文 4.远程控制。 </p>
<!-- more  -->   

<h1 id="烧录系统"><a href="#烧录系统" class="headerlink" title="烧录系统"></a>烧录系统</h1><p>官网下载raspbian系统镜像，用win32imagewriter将.img文件烧录进sd卡中,记得在根目录下加上ssh空白文件。（不然首次连接raspberry时会connection refused）</p>
</li>
</ol>
<h1 id="联有线网"><a href="#联有线网" class="headerlink" title="联有线网"></a>联有线网</h1><p>用网线连接路由器和raspberry即可，raspberry有指示灯闪烁。</p>
<h1 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h1><ol>
<li><p>通过路由器查看到raspberry的IP地址，我的是192.168.31.108。</p>
</li>
<li><p>ssh连接raspberry</p>
<blockquote>
<p>$ ssh <a href="mailto:&#x70;&#105;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#46;&#51;&#49;&#x2e;&#49;&#48;&#56;">&#x70;&#105;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#46;&#51;&#49;&#x2e;&#49;&#48;&#56;</a></p>
</blockquote>
<p> 在这里收到了connection refused。解决办法是在sd卡的根目录下加上一个ssh空白文件（无后缀）。</p>
</li>
<li><p>ssh pi@IP后会让输入密码，初始密码是raspberry，之后便进入了raspberry的终端。</p>
</li>
<li><p>raspberry端安装vnc程序</p>
<blockquote>
<p>$ sudo apt-get install tightvncserver</p>
</blockquote>
</li>
<li><p>raspberry端启动vnc：tightvncserver，出现端口号</p>
</li>
<li><p>mac端翻墙下载VNC viewer</p>
</li>
<li><p>mac端搜索IP:端口号</p>
<blockquote>
<p>192.168.31.108:1</p>
</blockquote>
<h1 id="使用无线网"><a href="#使用无线网" class="headerlink" title="使用无线网"></a>使用无线网</h1></li>
<li><p>配置WiFi信息<br>编辑 /etc/wpa_supplicant/wpa_supplicant.conf 文件<br>$ sudo nano /etc/wpa_supplicant/wpa_supplicant.conf<br>在文件末尾添加<br>network={ssid=“JB_F4” psk=“jb04250425”}</p>
</li>
<li><p>重启<br>$ sudo reboot</p>
</li>
<li><p>进入路由器后台查看raspberry新的IP </p>
</li>
</ol>
<h1 id="树莓派的中文输入法安装及配置"><a href="#树莓派的中文输入法安装及配置" class="headerlink" title="树莓派的中文输入法安装及配置"></a>树莓派的中文输入法安装及配置</h1><ol>
<li><p>在安装软件包之前，可以通过运行更新，确保apt缓存是最新的</p>
<blockquote>
<p>$ sudo apt-get update</p>
</blockquote>
</li>
<li><p>安装输入法</p>
<blockquote>
<p>$ sudo apt-get install scim-pinyin</p>
</blockquote>
</li>
<li><p>激活</p>
<blockquote>
<p>$ sudo scim</p>
</blockquote>
<p> 出现Starting SCIM，表示激活完成，同时任务栏会显示键盘图标。（切换输入法快捷键：Ctrl+空格）</p>
</li>
<li><p>配置中文环境<br>在未配置中文环境时，系统是全英文的</p>
<blockquote>
<p>$ sudo raspi-config</p>
</blockquote>
<p>  进入raspi-config界面，依次选择<br>Internationalisation Options ——&gt; change_locale ——&gt; zh_CN.UTF-8 UTF-8<br>重启机器即完成中文环境配置。</p>
<h1 id="安装屏幕"><a href="#安装屏幕" class="headerlink" title="安装屏幕"></a>安装屏幕</h1><p><a href="http://bbs.elecfans.com/jishu_1110139_1_1.html">http://bbs.elecfans.com/jishu_1110139_1_1.html</a><br><a href="https://www.ncnynl.com/archives/201607/233.html">https://www.ncnynl.com/archives/201607/233.html</a></p>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><p>修改pi密码</p>
<blockquote>
<p>$ passwd pi</p>
</blockquote>
</li>
<li><p>开启root权限</p>
<blockquote>
<p>$ sudo passwd -unlock root </p>
</blockquote>
</li>
<li><p>修改root密码</p>
<blockquote>
<p>$ sudo passwd root</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/06/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="LeetCode-1458-最大的子序列点积"><a href="#LeetCode-1458-最大的子序列点积" class="headerlink" title="LeetCode 1458 最大的子序列点积"></a>LeetCode 1458 最大的子序列点积</h2><ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>
<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length, n = nums2.length, MIN_VALUE = -<span class="number">500000000</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">      	<span class="comment">// dp[i][j]表示 nums1[0 ... i-1] 和 nums2[0 ... j-1]的最大的子序列点积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dp) &#123;</span><br><span class="line">            Arrays.fill(d, MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + nums1[i - <span class="number">1</span>] * nums2[j - <span class="number">1</span>], </span><br><span class="line">                               dp[i][j - <span class="number">1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][j], </span><br><span class="line">                               nums1[i - <span class="number">1</span>] * nums2[j - <span class="number">1</span>]);</span><br><span class="line">   </span><br><span class="line">                max = max(dp[i][j], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>... arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            max = max &gt; a ? max : a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>各种排序的Java实现</title>
    <url>/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/BubbleSort.gif" width="70%">

<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = arr.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;     <span class="comment">// 循环 n-1 次</span></span><br><span class="line">           <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;	       <span class="comment">// 是否已经有序</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                   swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                   flag = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/SelectionSort.gif" width="70%">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;	<span class="comment">// 循环 n-1 次</span></span><br><span class="line">        <span class="keyword">int</span> min = arr[i], idx = i;	<span class="comment">// 记录最小值和索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; min)&#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != idx)&#123;</span><br><span class="line">            swap(arr, i, idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/InsertionSort.gif" width="70%">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;  	<span class="comment">// 循环 n-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/ShellSort.gif" width="70%">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = n / <span class="number">2</span>; k &gt; <span class="number">0</span>; k = k &gt;&gt; <span class="number">1</span>)&#123;  <span class="comment">// 增量序列：&#123;1, 2, 4, ...&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; i++)&#123;         <span class="comment">// 以k为增量，对子数组进行排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= k; j -= k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[j - k])&#123;</span><br><span class="line">                    swap(arr, j, j - k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/MergeSort.gif" width="70%">

<p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">      sort(arr, <span class="number">0</span>, arr.length -  <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      sort(arr, low, mid);</span><br><span class="line">      sort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">      merge(arr, low, mid, high);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[low...mid]和arr[mid+1...high]已经有序</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] tmpArr = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[i] &lt; arr[j])&#123;</span><br><span class="line">              tmpArr[k++] = arr[i];</span><br><span class="line">              i++;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              tmpArr[k++] = arr[j];</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">          tmpArr[k++] = arr[i++];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(j &lt;= high)&#123;</span><br><span class="line">          tmpArr[k++] = arr[j++];</span><br><span class="line">      &#125;</span><br><span class="line">      System.arraycopy(tmpArr, <span class="number">0</span>, arr, low, tmpArr.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;   <span class="comment">// 间隔，两两合并</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt;= n; i += k * <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = i, mid = low + k - <span class="number">1</span>, high = low + k * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(high &gt; n - <span class="number">1</span>)&#123;</span><br><span class="line">                high = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            merge(arr, low, mid, high);</span><br><span class="line">        &#125;</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/QuickSort.gif" width="70%">

<p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    quickSortHelper(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortHelper</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 枢轴将数组一分为二，使得左边的值都小于枢轴值，右边的值都大于枢轴值</span></span><br><span class="line">    <span class="keyword">int</span> pivot = partition(arr, low, high);</span><br><span class="line">    quickSortHelper(arr, low, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSortHelper(arr, pivot + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(high &gt; low &amp;&amp; arr[high] &gt;= pivot)</span><br><span class="line">            high--;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(high &gt; low &amp;&amp; arr[low] &lt;= pivot)</span><br><span class="line">            low++;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortHelper</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(high);</span><br><span class="line">    stack.push(low);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        low = stack.pop();</span><br><span class="line">        high = stack.pop();</span><br><span class="line">      	<span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(arr, low, high);</span><br><span class="line">        stack.push(pivot - <span class="number">1</span>);</span><br><span class="line">        stack.push(low);</span><br><span class="line">        stack.push(high);</span><br><span class="line">        stack.push(pivot + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/HeapSort.gif" width="70%">

<p>非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建大顶堆（小顶堆）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 从第一个非叶子从下至上，从右至左调整堆</span></span><br><span class="line">        adjustDown(arr, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;    <span class="comment">// 循环 n-1 次</span></span><br><span class="line">        swap(arr, j, <span class="number">0</span>);	       <span class="comment">// 将最大值（最小值）交换至末尾</span></span><br><span class="line">        adjustDown(arr, <span class="number">0</span>, j);         <span class="comment">// 重新调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; len; k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">      	<span class="comment">// k指向子结点中大的那一个</span></span><br><span class="line">        <span class="keyword">if</span>(k + <span class="number">1</span> &lt; len &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>])&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[k] &gt; tmp)&#123;</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;	<span class="comment">// i指向放置tmp的位置</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= len)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k + <span class="number">1</span> &lt; len &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>])&#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; len &amp;&amp; arr[k] &gt; arr[i])&#123;</span><br><span class="line">        swap(arr, k, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adjustDown(arr, k, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/CountingSort.gif" width="70%">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要给定数组中的最小值和最大值</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[Math.abs(max - min) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">        count[a - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; count.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[j++] = i + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><img src="/2020/03/04/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/RadixSort.gif" width="70%">



<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    arr[i] = arr[i] + arr[j];</span><br><span class="line">    arr[j] = arr[i] - arr[j];</span><br><span class="line">    arr[i] = arr[i] - arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>
<p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/2019/10/31/%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<p> Input: “AAB”</p>
<p> Output: 8</p>
<p> Explanation: The possible sequences are “A”, “B”, “AA”, “AB”, “BA”, “AAB”, “ABA”, “BAA”.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(String tiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : tiles.toCharArray())</span><br><span class="line">            count[ch - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">return</span> dfs(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            count[i]--;</span><br><span class="line">            sum++;</span><br><span class="line">            sum += dfs(count);</span><br><span class="line">            count[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2019/09/13/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求不包含重复数字的数组的子集</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">        backtrack(list, nums, i + <span class="number">1</span>);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求包含重复数字的数字的子集</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">        backtrack(list, nums, i + <span class="number">1</span>);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>字符串匹配KMP算法</title>
    <url>/2020/03/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8DKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">子字符串</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">z</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最大匹配数</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>含义：字符串的所有真前缀和所有真后缀的最大匹配长度。</p>
<table>
<thead>
<tr>
<th align="center">子字符串</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">z</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
</tr>
</thead>
<tbody><tr>
<td align="center">next数组</td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>含义：当发生不匹配时，pattern字符串的指针应回退的位置。next数组是由上述的最大匹配数整体右移，并且next[0]等于-1。</p>
<a id="more"></a>



<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的next数组直接存储的最大匹配数，通过 j = next[j - 1]实现了上述右移操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span></span>&#123;</span><br><span class="line">    <span class="comment">// text 中寻找 pattern，返回所有匹配位置的起始下标列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">search</span><span class="params">(String text, String pattern)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; positions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (text == <span class="keyword">null</span> || pattern == <span class="keyword">null</span> || text.length() == <span class="number">0</span> || pattern.length() == <span class="number">0</span> || pattern.length() &gt; text.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> positions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = text.length(), m = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] next = calculateNext(pattern);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针：i指向text，不回退；j指向pattern，根据next数组回退</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text.charAt(i) != pattern.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i) == pattern.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                positions.add(i - m + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 假装不匹配，j继续回退，向后查找</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> positions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pattern 的最大匹配数表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] calculateNext(String pattern) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (maxLength &gt; <span class="number">0</span> &amp;&amp; pattern.charAt(maxLength) != pattern.charAt(i)) &#123;</span><br><span class="line">                <span class="comment">// 在下一个字符不匹配的情况下，找出次大的匹配长度</span></span><br><span class="line">                maxLength = next[maxLength - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(maxLength) == pattern.charAt(i)) &#123;</span><br><span class="line">                maxLength++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = maxLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/21923021">https://www.zhihu.com/question/21923021</a></p>
]]></content>
  </entry>
  <entry>
    <title>小瞿小瞿 充满乐趣</title>
    <url>/2020/02/26/%E5%B0%8F%E7%9E%BF%E5%B0%8F%E7%9E%BF-%E5%85%85%E6%BB%A1%E4%B9%90%E8%B6%A3/</url>
    <content><![CDATA[<img src="/2020/02/26/%E5%B0%8F%E7%9E%BF%E5%B0%8F%E7%9E%BF-%E5%85%85%E6%BB%A1%E4%B9%90%E8%B6%A3/qu.jpg" width="30%" height="30%">]]></content>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2020/03/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>由比特数组（位图）和哈希函数构成。</p>
<a id="more"></a>

<img src="/2020/03/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/bloom_filter.jpg" width="70%">

<p>对每个元素进行多次不同的哈希，将得到的哈希值对位图大小取余，然后将位图上对应位置置为1。查询时同样对元素进行哈希并取余，查看对应位置是否全为1。如果全为1，则元素可能存在，否则元素一定不存在。</p>
<h2 id="误判率"><a href="#误判率" class="headerlink" title="误判率"></a>误判率</h2><p>$$p={(1-e^{-\frac{nk}{m}})}^k$$</p>
<p>p：误判率（元素不存在，布隆过滤器判断其存在的概率）</p>
<p>n：元素个数</p>
<p>m：位图大小</p>
<p>k：哈希函数个数</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>大规模数据、空间小、不需要精确过滤</strong>的场景，如检查垃圾邮件地址，爬虫URL地址去重，解决缓存穿透问题等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wuer888/p/11236164.html">https://www.cnblogs.com/wuer888/p/11236164.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/01/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集重要思想：用集合中的一个元素代表集合。最初每个元素在各自的集合中，随着不断的合并，逐渐形成森林结构，森林中的每一棵树代表一个集合，其根节点则为代表元素。</p>
<ul>
<li><p>合并（union）</p>
<p>  将两个不相交的集合合并为一个集合。</p>
</li>
<li><p>查询（find）</p>
<p>  查询两个元素是否在同一个集合中。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="keyword">int</span> setCount;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.setCount = n;   <span class="comment">// 连通分量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        setCount--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 查找x属于哪个集合(向上递归查找直至根节点)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : (parent[x] = find(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li><p>路径压缩</p>
<p>  union形成的树深度可能会很大，但是我们find时只需要找到根节点，所以可以在find过程中，把沿途的每个节点的父节点都设为根节点即可。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  parent[x] = find(parent[x]);</span><br><span class="line">  <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>控制Goroutine并发数量</title>
    <url>/2021/07/09/%E6%8E%A7%E5%88%B6Goroutine%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h2 id="chan-sync"><a href="#chan-sync" class="headerlink" title="chan + sync"></a>chan + sync</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用chan限制goroutine并发数</span></span><br><span class="line">   <span class="keyword">var</span> goroutine_cnt = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">      goroutine_cnt &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="comment">// 业务逻辑</span></span><br><span class="line">         ch &lt;- strconv.FormatInt(<span class="keyword">int64</span>(i), <span class="number">10</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;index: %d, goroutine Num: %d\n&quot;</span>, i, runtime.NumGoroutine())</span><br><span class="line"></span><br><span class="line">         wg.Done()</span><br><span class="line">         &lt;- goroutine_cnt</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>原码、反码和补码</title>
    <url>/2020/03/01/%E6%95%B0%E5%80%BC%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<p>计算机所有数值都以补码形式存储，加减运算都是补码之间的加法运算。</p>
<blockquote>
<p>原码表示法是机器数的一种简单的表示法。其符号位用0表示正号，用1表示负号，数值一般用二进制形式表示。<br>机器数的反码可由原码得到。如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码是对它的原码（符号位除外）各位取反而得到的。<br>机器数的补码可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（除符号位外）各位取反，并在未位加1而得到的。</p>
</blockquote>
<!-- more  -->

<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>最高位为符号位，0代表正数，1代表负数。</p>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>正数的反码与原码相同。负数的反码是在原码的基础上按位取反（除符号位外）。</p>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>正数的补码与原码相同。负数的补码 = 反码 + 1，计算公式：$[X]_补 = 2^n － |X|$</p>
<table>
<thead>
<tr>
<th align="center">十进制数</th>
<th align="center">原码</th>
<th align="center">反码</th>
<th align="center">补码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8</td>
<td align="center">0000 1000</td>
<td align="center">0000 1000</td>
<td align="center">0000 1000</td>
</tr>
<tr>
<td align="center">-8</td>
<td align="center">1000 1000</td>
<td align="center">1111 0111</td>
<td align="center">1111 1000</td>
</tr>
<tr>
<td align="center">127</td>
<td align="center">0111 1111</td>
<td align="center">0111 1111</td>
<td align="center">0111 1111</td>
</tr>
<tr>
<td align="center">-127</td>
<td align="center">1111 1111</td>
<td align="center">1000 0000</td>
<td align="center">1000 0001</td>
</tr>
<tr>
<td align="center">-128</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1000 0000</td>
</tr>
</tbody></table>
<h4 id="为什么-128没有原码和反码，而补码为1000-0000"><a href="#为什么-128没有原码和反码，而补码为1000-0000" class="headerlink" title="为什么-128没有原码和反码，而补码为1000 0000"></a>为什么-128没有原码和反码，而补码为1000 0000</h4><p>原码和反码的表示范围为[-127 ~ 127]。0是不用区分正负的，如果按照上述规则，那么0有两个补码0000 0000和1000 0000</p>
<table>
<thead>
<tr>
<th align="center">十进制数</th>
<th align="center">原码</th>
<th align="center">反码</th>
<th align="center">补码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+0</td>
<td align="center">0000 0000</td>
<td align="center">0000 0000</td>
<td align="center">0000 0000</td>
</tr>
<tr>
<td align="center">-0</td>
<td align="center">1000 0000</td>
<td align="center">1111 1111</td>
<td align="center">1000 0000</td>
</tr>
</tbody></table>
<p>而<br>$$[0]_补 = [+1]_补 + [-1]_补 = 0000\ 0001B + 1111\ 1111B = 0000\ 0000B$$</p>
<p>$$[-128]_补 = [-1]_补 + [-127]_补 = 1111\ 1111B + 1000\ 0001B = 1000\ 0000B$$<br>故将1000 0000作为-128的补码，从而使这套规则能够自洽。</p>
<h4 id="4位存储示例"><a href="#4位存储示例" class="headerlink" title="4位存储示例"></a>4位存储示例</h4><table>
<thead>
<tr>
<th align="center">十进制</th>
<th align="center">二进制</th>
<th align="center">十进制</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">-8</td>
<td align="center">1000</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0001</td>
<td align="center">-7</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0010</td>
<td align="center">-6</td>
<td align="center">1010</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0011</td>
<td align="center">-5</td>
<td align="center">1011</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0100</td>
<td align="center">-4</td>
<td align="center">1100</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0101</td>
<td align="center">-3</td>
<td align="center">1101</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0110</td>
<td align="center">-2</td>
<td align="center">1110</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">0111</td>
<td align="center">-1</td>
<td align="center">1111</td>
</tr>
</tbody></table>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.zhihu.com/question/20159860?sort=created">https://www.zhihu.com/question/20159860?sort=created</a><br><a href="https://blog.csdn.net/liuweiyuxiang/article/details/96774479">https://blog.csdn.net/liuweiyuxiang/article/details/96774479</a><br><a href="https://www.jianshu.com/p/36ec7a047f29">https://www.jianshu.com/p/36ec7a047f29</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>数学</title>
    <url>/2020/03/17/%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="斐波那契数列（Fibonacci）"><a href="#斐波那契数列（Fibonacci）" class="headerlink" title="斐波那契数列（Fibonacci）"></a>斐波那契数列（Fibonacci）</h2><p>递推定义：</p>
<p>$$F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2) (n\geq3, n \in N^*)$$</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">return</span> helper(n - <span class="number">1</span>, b, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = Integer.toBinaryString(n).toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ch : arr)&#123;</span><br><span class="line">            count += (ch == <span class="string">&#x27;1&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(Math.min(list.get(i) * <span class="number">2</span>, list.get(j) * <span class="number">3</span>), list.get(k) * <span class="number">5</span>);</span><br><span class="line">            list.add(min);</span><br><span class="line">            <span class="keyword">if</span>(min == list.get(i) * <span class="number">2</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span>(min == list.get(j) * <span class="number">3</span>)</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(min == list.get(k) * <span class="number">5</span>)</span><br><span class="line">                k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本同归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (high + low) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergeSort(arr, low, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i  = low,  j = mid + <span class="number">1</span>, k  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid  &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                tmp[k++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k++] = arr[j++];</span><br><span class="line">                count += mid - i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1000000007</span>) &#123;</span><br><span class="line">                    count %= <span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(tmp, <span class="number">0</span>, arr, low, tmp.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = num1 ^ num2;</span><br><span class="line">            <span class="keyword">int</span> n2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = n1;</span><br><span class="line">            num2 = n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><p>递推方程<br>$$<br>f(i,j)=\begin{cases}<br>true,\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\ i=j\\<br>S[i]=S[j],\quad\quad\quad\quad\quad\quad\quad\quad\quad\ \ j=i+1\\<br>S[i]=S[j]\ and\ f(i+1,j-1),\quad\   j&gt;i+1\\<br>\end{cases}<br>$$</p>
<h2 id="杨辉三角（帕斯卡三角）"><a href="#杨辉三角（帕斯卡三角）" class="headerlink" title="杨辉三角（帕斯卡三角）"></a>杨辉三角（帕斯卡三角）</h2><img src="/2020/03/17/%E6%95%B0%E5%AD%A6/pascal.gif">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList());</span><br><span class="line">        ans.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> LinkedList();</span><br><span class="line">            List&lt;Integer&gt; preRow = ans.get(i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;  j &lt; preRow.size(); j++) &#123;</span><br><span class="line">                row.add(preRow.get(j - <span class="number">1</span>) + preRow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line">            ans.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2020/03/12/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; target)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// 插入点（从1开始计数）的相反数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target)</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, high, target);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, low, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第K大的数"><a href="#第K大的数" class="headerlink" title="第K大的数"></a>第K大的数</h2><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = array.length, col = array[<span class="number">0</span>].length;</span><br><span class="line">      	<span class="comment">// 从二维数组的右上角开始查找</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][j])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">if</span>(array[n - <span class="number">1</span>] &gt; array[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[low] &gt;= array[high])&#123;</span><br><span class="line">            <span class="keyword">if</span>(high == low + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> array[high];</span><br><span class="line">            mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// &#123;0, 1, 1, 1, 1&#125; == &gt; &#123;1, 0, 1, 1, 1&#125;  &#123;1, 1, 1, 0, 1&#125;</span></span><br><span class="line">            <span class="keyword">if</span>(array[low] == array[high] &amp;&amp; array[mid] == array[low])&#123;</span><br><span class="line">                <span class="keyword">return</span> minInOrder(array, low, high);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[low] &lt;= array[mid])&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt;= array[high])&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minInOrder</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = array[low];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; i++)&#123;</span><br><span class="line">            min = (min &lt; array[i]) ? min : array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] move = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = -<span class="number">1</span>, direc = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row * col; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = direc; j &lt; <span class="number">4</span>; j = (j + <span class="number">1</span>) % <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> nextX = x + move[j][<span class="number">0</span>], nextY = y + move[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(nextX &lt; <span class="number">0</span> || nextX &gt;= row || nextY &lt; <span class="number">0</span> || nextY &gt;= col)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!visited[nextX][nextY])&#123;</span><br><span class="line">                    direc = j;</span><br><span class="line">                    x = nextX;</span><br><span class="line">                    y = nextY;</span><br><span class="line">                    ans.add(matrix[nextX][nextY]);</span><br><span class="line">                    visited[nextX][nextY] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : numbers)&#123;</span><br><span class="line">            list.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">                String s1 = a + <span class="string">&quot;&quot;</span> + b;</span><br><span class="line">                String s2 = b + <span class="string">&quot;&quot;</span> + a;</span><br><span class="line">                <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> li : list)&#123;</span><br><span class="line">            ans.append(String.valueOf(li));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : array)&#123;</span><br><span class="line">            xor ^= a;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 找出xor的最低位的1，其他位置零</span></span><br><span class="line">        <span class="keyword">int</span> diff = xor &amp; (-xor);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : array)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a &amp; diff) == <span class="number">0</span>)</span><br><span class="line">                num1[<span class="number">0</span>] ^= a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] ^= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个整型数组里除了一个数字之外，其他的数字都出现了三次。请写程序找出这两个只出现一次的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                sum += (arr[j] &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sum % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> once = <span class="number">0</span>, twice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            once = (once ^ n) &amp; ~twice;</span><br><span class="line">            twice = (twice ^ n) &amp; ~once; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> once;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h2><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(high &gt; low)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = (high + low) * (high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(list);</span><br><span class="line">                low++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s &lt; sum)&#123;</span><br><span class="line">                high++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Shuffle-the-Array"><a href="#Shuffle-the-Array" class="headerlink" title="Shuffle the Array"></a>Shuffle the Array</h2><p>nums = [x1, x2, … , xn, y1, y2, … , yn]    ( 1&lt;= nums[i] &lt; 65536)</p>
<p>return [x1, y1, x2, y2, … , xn, yn]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            nums[i] &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">            nums[i] |= nums[i - n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            nums[i] = nums[n + i / <span class="number">2</span>] &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">            nums[i + <span class="number">1</span>] = nums[n + i / <span class="number">2</span>] &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>日志收集框架flume</title>
    <url>/2020/01/31/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%A1%86%E6%9E%B6flume/</url>
    <content><![CDATA[<h1 id="Flume架构"><a href="#Flume架构" class="headerlink" title="Flume架构"></a>Flume架构</h1><img src="/2020/01/31/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%A1%86%E6%9E%B6flume/01/31/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%A1%86%E6%9E%B6flume/flume%E6%9E%B6%E6%9E%84.png" class>
<a id="more"></a>


<h3 id="网络端口-gt-gt-控制台"><a href="#网络端口-gt-gt-控制台" class="headerlink" title="网络端口 &gt;&gt; 控制台"></a>网络端口 &gt;&gt; 控制台</h3><p>配置文件 $FLUME_HOME/conf/example.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># example.conf: A single-node Flume configuration</span><br><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources &#x3D; r1</span><br><span class="line">a1.sinks &#x3D; k1</span><br><span class="line">a1.channels &#x3D; c1</span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source</span><br><span class="line">a1.sources.r1.type &#x3D; netcat</span><br><span class="line">a1.sources.r1.bind &#x3D; localhost</span><br><span class="line">a1.sources.r1.port &#x3D; 44444</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type &#x3D; logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type &#x3D; memory</span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000</span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels &#x3D; c1</span><br><span class="line">a1.sinks.k1.channel &#x3D; c1</span><br></pre></td></tr></table></figure>
<p>启动agent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME&#x2F;conf \</span><br><span class="line">--conf-file $FLUME_HOME&#x2F;conf&#x2F;example.conf \</span><br><span class="line">-Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet localhost 44444</span><br></pre></td></tr></table></figure>
<h3 id="文件新增数据-gt-gt-控制台"><a href="#文件新增数据-gt-gt-控制台" class="headerlink" title="文件新增数据 &gt;&gt; 控制台"></a>文件新增数据 &gt;&gt; 控制台</h3><p>配置文件 $FLUME_HOME/conf/example.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # example.conf: A single-node Flume configuration</span><br><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources &#x3D; r1</span><br><span class="line">a1.sinks &#x3D; k1</span><br><span class="line">a1.channels &#x3D; c1</span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source</span><br><span class="line">a1.sources.r1.type &#x3D; exec</span><br><span class="line">a1.sources.r1.command &#x3D; tail -F &#x2F;Users&#x2F;wsc&#x2F;hadoop&#x2F;app&#x2F;flume&#x2F;conf&#x2F;data.log</span><br><span class="line">a1.sources.r1.shell &#x3D; &#x2F;bin&#x2F;sh -c</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type &#x3D; logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type &#x3D; memory</span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000</span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels &#x3D; c1</span><br><span class="line">a1.sinks.k1.channel &#x3D; c1</span><br></pre></td></tr></table></figure>
<p>启动agent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME&#x2F;conf \</span><br><span class="line">--conf-file $FLUME_HOME&#x2F;conf&#x2F;example.conf \</span><br><span class="line">-Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>
<h3 id="A服务器日志-gt-gt-B服务器kafka"><a href="#A服务器日志-gt-gt-B服务器kafka" class="headerlink" title="A服务器日志 &gt;&gt; B服务器kafka"></a>A服务器日志 &gt;&gt; B服务器kafka</h3><p>A服务器 exec-memory-avro.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # example.conf: A single-node Flume configuration</span><br><span class="line"># Name the components on this agent</span><br><span class="line">exec-memory-avro.sources &#x3D; exec-source</span><br><span class="line">exec-memory-avro.sinks &#x3D; avro-sink</span><br><span class="line">exec-memory-avro.channels &#x3D; memory-channel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source</span><br><span class="line">exec-memory-avro.sources.exec-source.type &#x3D; exec</span><br><span class="line">exec-memory-avro.sources.exec-source.command &#x3D; tail -F &#x2F;Users&#x2F;wsc&#x2F;hadoop&#x2F;app&#x2F;flume&#x2F;conf&#x2F;data.log</span><br><span class="line">exec-memory-avro.sources.exec-source.shell &#x3D; &#x2F;bin&#x2F;sh -c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">exec-memory-avro.sinks.avro-sink.type &#x3D; avro</span><br><span class="line">exec-memory-avro.sinks.avro-sink.hostname &#x3D; localhost</span><br><span class="line">exec-memory-avro.sinks.avro-sink.port &#x3D; 44444</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">exec-memory-avro.channels.memory-channel.type &#x3D; memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">exec-memory-avro.sources.exec-source.channels &#x3D; memory-channel</span><br><span class="line">exec-memory-avro.sinks.avro-sink.channel &#x3D; memory-channel</span><br></pre></td></tr></table></figure>
<p>B服务器 avro-memory-kafka.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # example.conf: A single-node Flume configuration</span><br><span class="line"># Name the components on this agent</span><br><span class="line">avro-memory-kafka.sources &#x3D; avro-source</span><br><span class="line">avro-memory-kafka.sinks &#x3D; kafka-sink</span><br><span class="line">avro-memory-kafka.channels &#x3D; memory-channel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source</span><br><span class="line">avro-memory-kafka.sources.avro-source.type &#x3D; avro</span><br><span class="line">avro-memory-kafka.sources.avro-source.bind &#x3D; localhost</span><br><span class="line">avro-memory-kafka.sources.avro-source.port &#x3D; 44444</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.type &#x3D; org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.brokerList &#x3D; localhost:9092</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.topic &#x3D; hello_topic</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.batchSize &#x3D; 5</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.requireAcks  &#x3D; 1</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">avro-memory-kafka.channels.memory-channel.type &#x3D; memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">avro-memory-kafka.sources.avro-source.channels &#x3D; memory-channel</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.channel &#x3D; memory-channel</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line"> --name avro-memory-kafka \</span><br><span class="line"> --conf $FLUME_HOME&#x2F;conf \</span><br><span class="line"> --conf-file $FLUME_HOME&#x2F;conf&#x2F;avro-memory-kafka.conf \</span><br><span class="line"> -Dflume.root.logger&#x3D;INFO,console</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> flume-ng agent \</span><br><span class="line"> --name exec-memory-avro \</span><br><span class="line"> --conf $FLUME_HOME&#x2F;conf \</span><br><span class="line"> --conf-file $FLUME_HOME&#x2F;conf&#x2F;exec-memory-avro.conf \</span><br><span class="line"> -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>最大单词长度乘积</title>
    <url>/2019/09/16/%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="Leetcode-318-最大单词长度乘积"><a href="#Leetcode-318-最大单词长度乘积" class="headerlink" title="Leetcode 318. 最大单词长度乘积"></a>Leetcode 318. 最大单词长度乘积</h1><blockquote>
<p><a href="https://leetcode.com/problems/maximum-product-of-word-lengths/">https://leetcode.com/problems/maximum-product-of-word-lengths/</a></p>
</blockquote>
<p>题意：给定一个字符串数组words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。假定每个单词只包含小写字母。如果不存在这样的两个单词，返回0。</p>
<pre><code>输入：[&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]
输出： 16
解释：这两个单词是 “abcw”, “xtfn”。
</code></pre>
<a id="more"></a>
<p>我的解题思路是将单词两两相比较，判断是否包含公共字母，如果不包含的话则记录当前的最大乘积。判断两个单词是否包含公共字母，我利用一个数组记录第一个字符串字母出现次数，然后在遍历第二个字符串时查询字母是否出现过，如果出现次数不为零，则代表两个单词有公共字母。两两字符串相比较，总共比较 (N - 1) + (N - 2) + … + 1 = N * (N - 1) / 2次，比较过程需要遍历两个字符串，故时间复杂度为O(N2 * L)，N为字符串数组的长度，L为字符的平均长度。每次记录单词的字母出现次数都需要一个长度为26的数组，共需要 26 * N * (N – 1) / 2 * 4字节的空间，故空间复杂度为O(N2)。代码见附录1-1。</p>
<p>上述算法是利用数组来记录字符串中字母出现的次数，需要26个int型整数，但是本题并不关心某个字母出现多少次，而是关心其是否出现过，即可以用 0 和 1 来表示某个字母出现与否，小写字母总共26个，即只需一个32位的int型整数即可。采用位掩码和或运算记录字母的出现情况。时空复杂度同上。代码见附录1-2 。</p>
<p>算法仍然有不足的地方。在上述算法中，每一个字符串都要进行 N – 1次遍，如果N很大的话，该重复操作会十分浪费时间。我们可以利用数组记录每个单词对应的整数，当重复查询时，即可在数组中查询。代码见附录1-3。</p>
<p>上述改进一直是着眼于判断两个单词是否有公共字母这一部分，如果我们能够减少单词比较次数也能提高性能。如果单词所包含的字母相同，那么只需要记录那个最长的单词即可。例如 “ab”和 “aaaaabbbbbb”，我们只需拿后者进行计算，忽略长度更短的“ab“。我们利用HashMap即可实现。代码如1-4。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>1-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, n = words.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isShareLetters(words[i], words[j]))</span><br><span class="line">                    max = Math.max(max, words[i].length() * words[j].length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShareLetters</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] letters = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : a.toCharArray())&#123;</span><br><span class="line">            letters[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : b.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(letters[ch - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1-2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, n = words.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isShareLetters(words[i], words[j]))</span><br><span class="line">                    max = Math.max(max, words[i].length() * words[j].length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShareLetters</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitmask1 = <span class="number">0</span>, bitmask2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : a.toCharArray())</span><br><span class="line">                bitmask1 |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : b.toCharArray())</span><br><span class="line">                bitmask2 |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (bitmask1 &amp; bitmask2) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1-3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, n = words.length;</span><br><span class="line">        <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] len = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch : words[i].toCharArray())</span><br><span class="line">                bitmask |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            masks[i] = bitmask;</span><br><span class="line">            len[i] = words[i].length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)</span><br><span class="line">                    max = Math.max(len[i] * len[j], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1-4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.length, max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch : words[i].toCharArray())</span><br><span class="line">                bitmask |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            map.put(bitmask, Math.max(map.getOrDefault(bitmask, <span class="number">0</span>), words[i].length()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y : map.keySet())&#123;</span><br><span class="line">                <span class="keyword">if</span>((x &amp; y) == <span class="number">0</span>)</span><br><span class="line">                    max = Math.max(max, map.get(x) * map.get(y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
  </entry>
  <entry>
    <title>服务器免密登录</title>
    <url>/2021/05/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h4 id="设置服务器"><a href="#设置服务器" class="headerlink" title="设置服务器"></a>设置服务器</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes     # RSA认证</span><br><span class="line">PubkeyAuthentication yes  # 公钥认证</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys  # 公钥认证文件路径</span><br></pre></td></tr></table></figure>


<h4 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure>


<h4 id="将公钥加入到服务器的-ssh-authorized-keys-中"><a href="#将公钥加入到服务器的-ssh-authorized-keys-中" class="headerlink" title="将公钥加入到服务器的 ~/.ssh/authorized_keys 中"></a>将公钥加入到服务器的 ~/.ssh/authorized_keys 中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i id_rsa user@host</span><br></pre></td></tr></table></figure>


<h4 id="配置本地config文件"><a href="#配置本地config文件" class="headerlink" title="配置本地config文件"></a>配置本地config文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host server           			# 机器的名字</span><br><span class="line">HostName xx.xx.xx.xx  			# 服务器IP</span><br><span class="line">User root         					# ssh登陆时候的用户名，一般是root</span><br><span class="line">Port 22               			# ssh所使用的端口，默认是22</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa 	# 私钥文件路径</span><br></pre></td></tr></table></figure>
<p>如果 config 文件不存在，那么手动新建后记得</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod 600 config</span><br></pre></td></tr></table></figure>


<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>将 .ssh 底下的所有文件权限修改为 600 ，防止其他人读写。</p>
]]></content>
  </entry>
  <entry>
    <title>Mac安装UE4：未在此Mac上检测到Xcode</title>
    <url>/2020/03/19/%E6%9C%AA%E5%9C%A8%E6%AD%A4Mac%E4%B8%8A%E6%A3%80%E6%B5%8B%E5%88%B0Xcode/</url>
    <content><![CDATA[<h4 id="1-确保Xcode-app安装路径为-Applications-Xcode-app。"><a href="#1-确保Xcode-app安装路径为-Applications-Xcode-app。" class="headerlink" title="1. 确保Xcode.app安装路径为/Applications/Xcode.app。"></a>1. 确保Xcode.app安装路径为/Applications/Xcode.app。</h4><h4 id="2-修改Xcode使用版本"><a href="#2-修改Xcode使用版本" class="headerlink" title="2. 修改Xcode使用版本"></a>2. 修改Xcode使用版本</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo xcode-select -s /Applications/Xcode.app/Contents/Developer</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>机器学习总结（自然语言处理课程）</title>
    <url>/2020/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B%EF%BC%89/</url>
    <content><![CDATA[<ol>
<li><p>给定一个任务</p>
<p> 垃圾邮件分类器</p>
</li>
<li><p> 给定一个训练集</p>
<p> 若干已标记邮件（垃圾 or 正常）</p>
</li>
<li><p>构造一个参数化的模型</p>
</li>
</ol>
<a id="more"></a>

<ul>
<li><p>垃圾邮件和正常邮件用词方面不同，选择n个词作为特征（具有区分邮件垃圾与否的能力），故可以将每封邮件表示为n维向量。$x_i$表示特征i在邮件中出现的次数。</p>
<p>  $$x = (x_1, x_2, …, x_n)$$</p>
</li>
<li><p>假定一个线性函数</p>
<p>  $$f(x)= w_1x_1 + w_2x_2 + … + w_nx_n + b = w^Tx + b$$</p>
<p>  $w_i$为特征i的权重。</p>
</li>
<li><p>模型参数$\theta = (w, b)$</p>
</li>
</ul>
<ol start="4">
<li><p>定义损失函数$L(y,Y)$，y是模型计算结果，Y是人工标注结果。如果模型判别正确，损失为0，否则大于0。平均损失函数<br> $$L(y,Y) = \frac{1}{n}\sum_{i=1}^n L(y_i,Y_i) $$</p>
</li>
<li><p>寻求可使训练集上损失最小的参数^θ，得到模型</p>
</li>
<li><p>利用模型处理未来的输入对象</p>
</li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2020/03/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; sMin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        s.push(node);</span><br><span class="line">        <span class="keyword">if</span>(sMin.isEmpty() || sMin.peek() &gt;= node)&#123;</span><br><span class="line">            sMin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="comment">// 对于Integer类型，如果用 == ，需要保证[-128,127]</span></span><br><span class="line">        <span class="keyword">if</span>(sMin.peek().equals(s.pop()))&#123;</span><br><span class="line">            sMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> s.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sMin.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> sMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="最小队列"><a href="#最小队列" class="headerlink" title="最小队列"></a>最小队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] A,<span class="keyword">int</span> [] B)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            s.push(A[i++]);</span><br><span class="line">            <span class="keyword">while</span>(!s.isEmpty() &amp;&amp; s.peek() == B[j])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seq.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPostorder(seq, <span class="number">0</span>, seq.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPostorder</span><span class="params">(<span class="keyword">int</span>[] seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> rootVal = seq[end], mid = start;</span><br><span class="line">        <span class="keyword">while</span>(seq[mid] &lt; rootVal &amp;&amp; mid &lt; end)</span><br><span class="line">            mid++;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> tmp = mid;</span><br><span class="line">        <span class="keyword">while</span>(seq[tmp] &gt; rootVal &amp;&amp; tmp &lt; end)</span><br><span class="line">            tmp++;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(tmp != end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(mid == start || mid == end)</span><br><span class="line">            <span class="keyword">return</span> isPostorder(seq, start, end - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> isPostorder(seq, start, mid - <span class="number">1</span>) &amp;&amp; isPostorder(seq, mid, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>B树 B-树 B+树 B*树</title>
    <url>/2020/03/04/%E6%A0%91/</url>
    <content><![CDATA[<p>B-树就是B树，中间的短横线是连接符，千万不要读成B减树了。</p>
<a id="more"></a>

<h2 id="B树（B-树）"><a href="#B树（B-树）" class="headerlink" title="B树（B-树）"></a>B树（B-树）</h2><blockquote>
<p>一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：<br>1、根结点至少有两个子女；<br>2、每个非根节点所包含的关键字个数 j 满足：$$\lceil m/2 \rceil - 1 &lt;= j &lt;= m - 1 $$<br>3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：$$ \lceil m/2 \rceil &lt;= k &lt;= m $$<br>4、所有的叶子结点都位于同一层。</p>
</blockquote>
<img src="/2020/03/04/%E6%A0%91/B-tree.png" width="60%">


<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><blockquote>
<p>m阶B+树有如下特征:<br>1、每个结点的关键字个数与孩子个数相等，所有非最下层的内层结点的关键字是对应子树上的最大关键字，最下层内部结点包含了全部关键字。<br>2、除根结点以外，每个内部结点有 到m个孩子。<br>3、所有叶结点在树结构的同一层，并且不含任何信息(可看成是外部结点或查找失败的结点)，因此，树结构总是树高平衡的。</p>
</blockquote>
<img src="/2020/03/04/%E6%A0%91/B+tree.jpg" width="60%">


<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><blockquote>
<p>B<em>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B</em>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baike.baidu.com/item/B%E6%A0%91/5411672?fr=aladdin">百度：B-树</a><br><a href="https://baike.baidu.com/item/B%2B%E6%A0%91">百度：B+树</a><br><a href="https://baike.baidu.com/item/B%2A%E6%A0%91">百度：B*树</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2020/10/07/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>对长度为n的数组A进行如下操作：</p>
<ol>
<li>求数组前缀和A[0]</li>
<li>修改指定下标的元素的值</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>遍历</p>
<ul>
<li>O(n)</li>
<li>O(1)</li>
</ul>
</li>
<li><p>辅助数组B记录前缀和</p>
<ul>
<li>O(1)</li>
<li>O(n)</li>
</ul>
</li>
<li><p>树状数组C</p>
<ul>
<li>O(logn)</li>
<li>O(logn)</li>
</ul>
</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><img src="/2020/10/07/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/1.png" width="50%">

]]></content>
  </entry>
  <entry>
    <title>深入理解计算机系统</title>
    <url>/2020/11/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="Chapter-1-计算机系统漫游"><a href="#Chapter-1-计算机系统漫游" class="headerlink" title="Chapter 1 计算机系统漫游"></a>Chapter 1 计算机系统漫游</h3><ul>
<li><p>计算机系统中所有的信息——包括磁盘文件、内存中的程序、用户数据以及网络传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。</p>
  <a id="more"></a>
</li>
<li><p>gcc -o hello hello.c 由编译系统（预处理器、编译器、汇编器和链接器）完成编译。</p>
<ul>
<li><p>预处理阶段</p>
<p>  预处理器根据以#字符开头的命令，修改原始程序，得到hello.i</p>
</li>
<li><p>编译阶段</p>
<p>  翻译成汇编语言，得到hello.s</p>
</li>
<li><p>汇编阶段</p>
<p>  翻译成机器语言，得到hello.o</p>
</li>
<li><p>链接阶段</p>
<p>  得到可执行文件</p>
</li>
</ul>
</li>
<li><p>处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。</p>
</li>
<li><p>存储器层次结构的主要思想是上一层存储器作为低一层存储器的高速缓存。</p>
</li>
<li><p>计算机系统中的一个重要思想是抽象。一个计算机系统提供不同层次的抽象表示，来隐藏实际实现的复杂性。</p>
<ul>
<li>文件是对I/O设备的抽象。</li>
<li>虚拟内存是对程序存储器的抽象。</li>
<li>进程是对一个正在运行的程序的抽象。</li>
<li>虚拟机提供了对整个计算机的抽象，包括操作系统、处理器和程序。</li>
<li>指令集架构提供了对实际处理器硬件的抽象。</li>
</ul>
</li>
<li><p>Amdahl定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p>
</li>
<li><p>计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。</p>
</li>
</ul>
<h3 id="Chapter-2-信息的表示和处理"><a href="#Chapter-2-信息的表示和处理" class="headerlink" title="Chapter 2 信息的表示和处理"></a>Chapter 2 信息的表示和处理</h3><ul>
<li>字节（byte）是最小的可寻址的内存单位，内存的每个字节都由一个唯一的数字来标识。</li>
<li>在几乎所有的机器上，多字节对象被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。</li>
<li>最高有效字节在最前面的方式称为大端法（big endian），最低有效字节在最前面的方式称为小端法（little endian）。大多数Intel兼容机都只用小端模式，Android和IOS只能运行于小端模式。</li>
<li>位运算符：|(or)  &amp;(and)  ~(not)  ^(exclusive-or)</li>
<li>逻辑运算符：||(or)  &amp;&amp;(and)  !(not)</li>
<li><a href="https://sicheng.wang/2020/03/01/%E6%95%B0%E5%80%BC%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/">原码、反码和补码</a> </li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>百度收录Hexo</title>
    <url>/2020/03/01/%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95Hexo/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/lfri/p/12260144.html">https://www.cnblogs.com/lfri/p/12260144.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2019/09/13/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>从1-n中取数，使其和为m，列出所有组合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; sumEqualToM(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> sum, <span class="keyword">int</span> pos)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum + pos == m)&#123;</span><br><span class="line">        list.add(pos);</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum + pos &lt; m)&#123;</span><br><span class="line">        list.add(pos);</span><br><span class="line">        sumEqualToM(n, m, sum + pos, pos + <span class="number">1</span>);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        sumEqualToM(n, m, sum, pos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; sumEqualToM(<span class="keyword">int</span> n, <span class="keyword">int</span> m)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(n == m)&#123;</span><br><span class="line">        list.add(n);</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(n);</span><br><span class="line">    sumEqualToM(n - <span class="number">1</span>, m - n);</span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    sumEqualToM(n - <span class="number">1</span>, m);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中取数，使其和为m，列出所有组合。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backtrack(nums, remain - nums[i], i);   <span class="comment">// 元素重复使用</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(start &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backtrack(nums, remain - nums[i], i + <span class="number">1</span>);   <span class="comment">// 元素不可重复使用</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>编译原理四个集合</title>
    <url>/2019/09/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9B%9B%E4%B8%AA%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>   在编译原理语法分析阶段，有四个十分抽象的集合：LL(1)分析法的First集、Follow集，算法优先分析法的Firstvt集、Lastvt集。下面是求这四个集合的具象方法。注意：First、Follow、Firstvt和Lastvt四个集合都是针对非终结符而言的，终结符没有这四个集合……</p>
<h1 id="First"><a href="#First" class="headerlink" title="First"></a>First</h1><p>求First(A)，观察以A为左部的所有产生式：</p>
<ul>
<li><p>直接收取：</p>
<ul>
<li>A -&gt; a… ，则 a ∈ First(A)</li>
<li>A -&gt; ε ，则 ε ∈ First(A)</li>
</ul>
</li>
<li><p>反复传递：A -&gt; BC…</p>
<ul>
<li><p>如果First(B)不含ε：First(B) ⊆ First(A)</p>
</li>
<li><p>如果First(B)含有ε：First(B) - {ε} ⊆ First(A)，并且还要对 A -&gt; C… 进行传递收取</p>
<a id="more"></a>

<h1 id="Follow"><a href="#Follow" class="headerlink" title="Follow"></a>Follow</h1><p>求Follow(A)，观察所有产生式的右部：</p>
</li>
</ul>
</li>
<li><p>如果A为开始符号，则 # ∈ Follow(A)</p>
</li>
<li><p>直接收取：</p>
<ul>
<li>B -&gt; …Aa… ，则 a ∈ Follow(A)</li>
<li>B -&gt; …AC… ，则 First(C) - {ε} ⊆ Follow(A)</li>
</ul>
</li>
<li><p>反复传递：B -&gt; …A ，则 Follow(B) ⊆ Follow(A) </p>
</li>
</ul>
<h1 id="Firstvt"><a href="#Firstvt" class="headerlink" title="Firstvt"></a>Firstvt</h1><p>求Firstvt(A)，观察以A为左部的所有产生式：</p>
<ul>
<li>A -&gt; a… ，则 a ∈ Firstvt(A)</li>
<li>A -&gt; B… ，则 Firstvt(B) ⊆ Firstvt(A)</li>
<li>A -&gt; Ba… ,则 a ∈ Firstvt(A)</li>
</ul>
<h1 id="Lastvt"><a href="#Lastvt" class="headerlink" title="Lastvt"></a>Lastvt</h1><p>求Lastvt(A)，观察以A为左部的所有产生式：</p>
<ul>
<li>A -&gt; …a ，则 a ∈ Lastvt(A)</li>
<li>A -&gt; …B ，则 Lastvt(B) ⊆ Lastvt(A)</li>
<li>A -&gt; …aB，则 a ∈ Lastvt(A)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计网知识点总结</title>
    <url>/2020/11/11/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h4><ul>
<li>应用层<br>  网络服务与最终用户的一个接口。<br>  协议：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</li>
<li>表示层<br>  数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）<br>  格式：JPEG、ASCll、EBCDIC、加密格式等</li>
<li>会话层<br>  建立、管理、终止会话。（在五层模型里面已经合并到了应用层）<br>  对应主机进程，指本地主机与远程主机正在进行的会话</li>
</ul>
<a id="more"></a>

<ul>
<li>传输层<br>  定义传输数据的协议端口号，以及流控和差错校验。<br>  协议：TCP UDP。数据包一旦离开网卡即进入网络传输层</li>
<li>网络层<br>  进行逻辑地址寻址，实现不同网络之间的路径选择。<br>  协议：ICMP IGMP IP（IPV4 IPV6）</li>
<li>数据链路层<br>  建立逻辑连接、进行硬件地址寻址、差错校验 [3]  等功能。（由底层网络定义协议）<br>  将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</li>
<li>物理层<br>  建立、维护、断开物理连接。（由底层网络定义协议）</li>
</ul>
<img src="/2020/11/11/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/osi.png">

<h4 id="TCP应用程序系统调用序列"><a href="#TCP应用程序系统调用序列" class="headerlink" title="TCP应用程序系统调用序列"></a>TCP应用程序系统调用序列</h4><table>
<thead>
<tr>
<th>TCP Client</th>
<th>TCP Server</th>
</tr>
</thead>
<tbody><tr>
<td>socket()</td>
<td>socket() 创建socket</td>
</tr>
<tr>
<td>bind()</td>
<td>bind() 将创建的socket绑定到指定的IP地址和端口上</td>
</tr>
<tr>
<td>connect() 用来与服务器建立一个TCP连接</td>
<td>listen() 仅被TCP类型的服务器程序调用，实现监听服务</td>
</tr>
<tr>
<td>send()</td>
<td>accept() 仅被TCP类型的服务器程序调用，从已完成连接队列返回下一个建立成功的连接，如果已完成连接队列为空，线程进入阻塞态睡眠状态</td>
</tr>
<tr>
<td>receive()</td>
<td>receive() TCP类型的数据发送</td>
</tr>
<tr>
<td></td>
<td>send() TCP类型的数据接收</td>
</tr>
</tbody></table>
<img src="/2020/11/11/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/socket.png">



<h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><img src="/2020/11/11/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/tcp_farewell.png">

<p>第四次挥手的ACK可能丢失，发送ACK的主机必须等待2MSL(Max Segement Livetime)时间后才能关闭连接。</p>
<p>出现太多TIME_WAIT的后果：在高并发短连接的TCP服务器上，会出现大量的socket处于TIME_WAIT状态，导致socket资源不足，服务器资源利用率低。</p>
<p>解决方案：设置socket时使用SO_REUSEADDR。一个端口释放后会等待2MSL之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。</p>
<h5 id="socket五元组"><a href="#socket五元组" class="headerlink" title="socket五元组"></a>socket五元组</h5><ul>
<li>Client IP</li>
<li>Client Port</li>
<li>Server IP</li>
<li>Server Port</li>
<li>Protocol</li>
</ul>
<h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><p>粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。即在TCP传输数据过程中，一次性recv了多个send数据。因为TCP是字节流传输协议，所以粘包不是由TCP处理的问题，而是由上层协议处理的问题。</p>
<h4 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h4><h4 id="拥塞控制和流量控制"><a href="#拥塞控制和流量控制" class="headerlink" title="拥塞控制和流量控制"></a>拥塞控制和流量控制</h4><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://blog.csdn.net/qq_37964547/article/details/81429627">https://blog.csdn.net/qq_37964547/article/details/81429627</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/128920084">https://zhuanlan.zhihu.com/p/128920084</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2020/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>代理模式提供了间接对目标对象进行访问的方式，即通过代理对象访问目标对象，并且能够在代码不改动的情况下实现目标对象功能的扩展。符合设计模式的开闭原则。</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Subject： 抽象主题类，该类就是一个接口，用于声明真是主题与代理的共同接口方法。</li>
<li>RealSubject：真实主题类，该类为被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务方法，Client则通过代理类来间接地调用该类的方法。</li>
<li>ProxySubject：代理类，该类持有一个真实主题的引用，在其所实现的接口方法中调用真实主题的处理方法。起到代理的作用。</li>
<li>Client：调用者</li>
</ul>
<a id="more"></a>

<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 歌手接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Singer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实歌手陈奕迅</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eason</span> <span class="keyword">implements</span> <span class="title">Singer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你当我是浮夸吧 夸张只因我很怕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经纪人（代理人）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">Singer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singer singer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">(Singer singer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.singer = singer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备工作&quot;</span>);</span><br><span class="line">        singer.sing();</span><br><span class="line">        System.out.println(<span class="string">&quot;收尾工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Eason eason = <span class="keyword">new</span> Eason();</span><br><span class="line">        Agent agent = <span class="keyword">new</span> Agent(eason);</span><br><span class="line">        agent.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：如果接口中增加方法，所有实现类要实现这个方法外所有代理类也要实现这个方法。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理能够在程序运行时JVM才为被代理对象生成代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 歌手接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Singer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实歌手陈奕迅</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eason</span> <span class="keyword">implements</span> <span class="title">Singer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你当我是浮夸吧 夸张只因我很怕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StarHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备工作&quot;</span>);</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;收尾工作&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Eason eason = <span class="keyword">new</span> Eason();</span><br><span class="line">        StarHandler starHandler = <span class="keyword">new</span> StarHandler(eason);</span><br><span class="line">        Singer proxy = (Singer)Proxy.newProxyInstance(eason.getClass().getClassLoader(), eason.getClass().getInterfaces(), starHandler);</span><br><span class="line">        proxy.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：代理对象不需要实现接口,但是目标对象一定要实现接口。</p>
<h2 id="CGLIB-Code-Generation-Library-代理"><a href="#CGLIB-Code-Generation-Library-代理" class="headerlink" title="CGLIB(Code Generation Library)代理"></a>CGLIB(Code Generation Library)代理</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li><p>优点： </p>
<ul>
<li>职责清晰</li>
<li>高扩展性 </li>
<li>智能化</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 </li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/jie-y/p/10732347.html">https://www.cnblogs.com/jie-y/p/10732347.html</a></p>
<p><a href="https://www.runoob.com/design-pattern/proxy-pattern.html">https://www.runoob.com/design-pattern/proxy-pattern.html</a></p>
<p><a href="https://blog.csdn.net/u012359453/article/details/79029478">https://blog.csdn.net/u012359453/article/details/79029478</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2020/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>使用单例可以减轻加载的负担，提高加载的效率，但并不是所有场景都适合使用单例。主要使用场景：</p>
<a id="more"></a>

<ol>
<li>控制资源的使用。通过线程同步控制并发访问。</li>
<li>控制实例的产生。</li>
<li>控制数据共享。在不建立直接关联的条件下，实现多个进程或线程的通信。</li>
</ol>
<h3 id="实现特点"><a href="#实现特点" class="headerlink" title="实现特点"></a>实现特点</h3><ol>
<li>构造方法私有化</li>
<li>单例的引用变量私有化</li>
<li>获取实例的方法公有</li>
</ol>
<h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><ol>
<li>饿汉式（立即加载）<br>优点：简单方便<br>缺点：类加载时会生成单例对象，降低了应用启动速度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>懒汉式（延迟加载）<br>优点：单例对象的生成是在应用需要使用时创建，可提高应用启动速度。<br>缺点：不加锁线程不安全，加锁有额外消耗</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronized方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重校验锁，synchronized块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="comment">// volatile防止重排序，new Instance()是非原子操作</span></span><br><span class="line">	<span class="comment">// （1）分配内存空间 （2）初始化对象 （3）将instance指向该内存空间</span></span><br><span class="line">	<span class="comment">// 可能会出现 （1）（3）（2）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;		<span class="comment">// 减少判断同步锁的次数</span></span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用内部静态类（延迟加载）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Holder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用枚举<br>优点：防反射攻击</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Sinleton</span></span>&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>要想实现效率高的线程安全的单例，必须注意以下两点：<ul>
<li>尽量减少同步块的作用域；</li>
<li>尽量使用细粒度的锁。</li>
</ul>
</li>
<li>私有化构造方法并不保险，特权客户端能够通过反射机制调用私有构造方法。可以修改构造方法，在创建第二个实例时抛出异常。</li>
<li>Joshua Bloch: “单元素的枚举类型是实现Singleton的最佳方法”。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/gan785160627/article/details/81946242">https://blog.csdn.net/gan785160627/article/details/81946242</a><br><a href="https://blog.csdn.net/czqqqqq/article/details/80451880">https://blog.csdn.net/czqqqqq/article/details/80451880</a><br><a href="https://www.cnblogs.com/chiclee/p/9097772.html">https://www.cnblogs.com/chiclee/p/9097772.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之工厂模式</title>
    <url>/2020/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂模式作用是帮助我们将对象实例化的部分抽离出来，从而降低代码的耦合度，增加系统的可扩展性。</p>
<h2 id="一、简单工厂模式（静态工厂模式）"><a href="#一、简单工厂模式（静态工厂模式）" class="headerlink" title="一、简单工厂模式（静态工厂模式）"></a>一、简单工厂模式（静态工厂模式）</h2><ol>
<li><p>产品接口类，用于区分冰激凌口味</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>产品实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleCream</span> <span class="keyword">implements</span> <span class="title">IceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple Cream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaCream</span> <span class="keyword">implements</span> <span class="title">IceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Banana Cream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeCream</span> <span class="keyword">implements</span> <span class="title">IceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange Cream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>工厂类，根据需要制作冰激凌</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCreamFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IceCream <span class="title">getIceCream</span><span class="params">(String taste)</span></span>&#123;</span><br><span class="line">        IceCream iceCream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (taste)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Apple&quot;</span>:</span><br><span class="line">                iceCream = <span class="keyword">new</span> AppleCream();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Banana&quot;</span>:</span><br><span class="line">                iceCream = <span class="keyword">new</span> BananaCream();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Orange&quot;</span>:</span><br><span class="line">                iceCream = <span class="keyword">new</span> OrangeCream();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;nothing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iceCream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IceCreamFactory iceCreamFactory = <span class="keyword">new</span> IceCreamFactory();</span><br><span class="line">        iceCreamFactory.getIceCream(<span class="string">&quot;Apple&quot;</span>).taste();</span><br><span class="line">        iceCreamFactory.getIceCream(<span class="string">&quot;Banana&quot;</span>).taste();</span><br><span class="line">        iceCreamFactory.getIceCream(<span class="string">&quot;Orange&quot;</span>).taste();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：一个工厂生产多种产品<br>优点：简单，封装了生产细节<br>缺点：违背了开闭原则，扩展性差</p>
</li>
</ol>
<h2 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h2><ol>
<li><p>产品接口类，产品实现类同上</p>
</li>
<li><p>工厂接口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IceCreamFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IceCream <span class="title">getIceCream</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>工厂实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleCreamFactory</span> <span class="keyword">implements</span> <span class="title">IceCreamFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IceCream <span class="title">getIceCream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppleCream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaCreamFactory</span> <span class="keyword">implements</span> <span class="title">IceCreamFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IceCream <span class="title">getIceCream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BananaCream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeCreamFactory</span> <span class="keyword">implements</span> <span class="title">IceCreamFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IceCream <span class="title">getIceCream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrangeCream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IceCreamFactory appleCreamFactory = <span class="keyword">new</span> AppleCreamFactory();</span><br><span class="line">        appleCreamFactory.getIceCream().taste();</span><br><span class="line"></span><br><span class="line">        IceCreamFactory bananaCreamFactory = <span class="keyword">new</span> BananaCreamFactory();</span><br><span class="line">        bananaCreamFactory.getIceCream().taste();</span><br><span class="line"></span><br><span class="line">        IceCreamFactory orangeCreamFactory = <span class="keyword">new</span> OrangeCreamFactory();</span><br><span class="line">        orangeCreamFactory.getIceCream().taste();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>特点：多个工厂，每个工厂只生产一种产品<br>优点：符合开闭原则，扩展性更好</p>
<h2 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h2><ol>
<li>产品接口类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BigIceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmallIceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>产品实现类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigAppleIceCream</span> <span class="keyword">implements</span> <span class="title">BigIceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Big Apple Cream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallAppleIceCream</span> <span class="keyword">implements</span> <span class="title">SmallIceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Small Apple Cream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>工厂接口类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IceCreamFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigIceCream <span class="title">getBigIceCream</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SmallIceCream <span class="title">getSmallIceCream</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>工厂实现类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleCreamFactory</span> <span class="keyword">implements</span> <span class="title">IceCreamFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigAppleIceCream <span class="title">getBigIceCream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigAppleIceCream();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SmallIceCream <span class="title">getSmallIceCream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmallAppleIceCream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消费者类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IceCreamFactory appleCreamFactory = <span class="keyword">new</span> AppleCreamFactory();</span><br><span class="line">        appleCreamFactory.getBigIceCream().taste();</span><br><span class="line">        appleCreamFactory.getSmallIceCream().taste();</span><br><span class="line"></span><br><span class="line">        IceCreamFactory bananaCreamFactory = <span class="keyword">new</span> BananaCreamFactory();</span><br><span class="line">        bananaCreamFactory.getBigIceCream().taste();</span><br><span class="line">        bananaCreamFactory.getSmallIceCream().taste();</span><br><span class="line"></span><br><span class="line">        IceCreamFactory orangeCreamFactory = <span class="keyword">new</span> OrangeCreamFactory();</span><br><span class="line">        orangeCreamFactory.getBigIceCream().taste();</span><br><span class="line">        orangeCreamFactory.getSmallIceCream().taste();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
特点：存在多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个具体的工厂生产多种产品。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_35985385/article/details/81430545">https://blog.csdn.net/weixin_35985385/article/details/81430545</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之适配器模式</title>
    <url>/2020/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>目标角色（target）：这是客户锁期待的接口。目标可以是具体的或抽象的类，也可以是接口</p>
<p>适配者角色（adaptee）：已有接口，但是和客户器期待的接口不兼容。</p>
<p>适配器角色（adapter）：将已有接口转换成目标接口。</p>
<a id="more"></a>

<h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><ul>
<li>类适配器模式</li>
</ul>
<img src="/2020/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/adaptor1.png" width="40%">    

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m method1.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m method2.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象适配器模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m method1.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        adaptee.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m method2.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>接口适配器模式（缺省适配器模式）</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li><p>优点</p>
<ul>
<li>更好的复用性：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>更好的扩展性：在实现适配器功能的时候，可以扩展自己源的行为（增加方法），从而自然地扩展系统的功能。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>会导致系统紊乱：滥用适配器，会让系统变得非常零乱。例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/design-pattern/adapter-pattern.html">https://www.runoob.com/design-pattern/adapter-pattern.html</a></p>
<p><a href="https://blog.csdn.net/mrkohaku/article/details/79087688">https://blog.csdn.net/mrkohaku/article/details/79087688</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>配置多个rsa秘钥</title>
    <url>/2020/03/01/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AArsa%E7%A7%98%E9%92%A5/</url>
    <content><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在本地生成了rsa秘钥对，将公钥上传至coding.net后，在首次建立连接时</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></table></figure>
<p>会出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git@e.coding.net: Permission denied (publickey).</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>之前配置github.com的ssh时，已经生成过一个id_rsa，现在.ssh文件夹下有两个秘钥对，系统不知道应该使用哪一个<br><img src="/2020/03/01/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AArsa%E7%A7%98%E9%92%A5/ssh.png" width="80%"></p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol>
<li><p>在.ssh文件夹下创建config文件，写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User wsc</span><br><span class="line">Port 22</span><br><span class="line">IdentityFile &#x2F;Users&#x2F;wsc&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line"></span><br><span class="line">Host e.coding.net</span><br><span class="line">HostName e.coding.net</span><br><span class="line">User root</span><br><span class="line">Port 22</span><br><span class="line">IdentityFile &#x2F;Users&#x2F;wsc&#x2F;.ssh&#x2F;id_rsa_codingNet</span><br><span class="line"></span><br><span class="line">Host tencent</span><br><span class="line">HostName 49.233.170.51</span><br><span class="line">User root</span><br><span class="line">Port 22</span><br><span class="line">IdentityFile &#x2F;Users&#x2F;wsc&#x2F;.ssh&#x2F;id_rsa_tencent</span><br></pre></td></tr></table></figure></li>
<li><p>清空known_hosts文件</p>
</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/qingguo/p/5686247.html">https://www.cnblogs.com/qingguo/p/5686247.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/03/12/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="公共结点"><a href="#公共结点" class="headerlink" title="公共结点"></a>公共结点</h2><p>找出两个链表的第一个公共结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = pHead1, p2  = pHead2;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = (p1 == <span class="keyword">null</span>) ? pHead2 : p1.next;</span><br><span class="line">        p2 = (p2 == <span class="keyword">null</span>) ? pHead1 : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="环入口结点"><a href="#环入口结点" class="headerlink" title="环入口结点"></a>环入口结点</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode fast = pHead, slow = pHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断链表是否包含环</span></span><br><span class="line">    <span class="keyword">boolean</span> isLoop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">            isLoop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isLoop)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode p = pHead, q = pHead;</span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>, p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode q = p.next;	<span class="comment">// 记录下一个结点</span></span><br><span class="line">        p.next = newHead;	<span class="comment">// 头插法</span></span><br><span class="line">        newHead = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    ListNode p = head.next;		<span class="comment">// p指向head的下一个结点</span></span><br><span class="line">    ListNode newHead = ReverseList(p);	<span class="comment">// 整体思维。p指向新链表最后一个结点</span></span><br><span class="line">    p.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> list2;</span><br><span class="line">      <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> list1;</span><br><span class="line">      <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">          list1.next = Merge(list1.next, list2);</span><br><span class="line">          <span class="keyword">return</span> list1;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          list2.next = Merge(list1, list2.next);</span><br><span class="line">          <span class="keyword">return</span> list2;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">      ListNode p = list1, q = list2, newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>), k = newHead;</span><br><span class="line">      <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p.val &lt; q.val)&#123;</span><br><span class="line">              k.next = p;</span><br><span class="line">              p = p.next;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              k.next = q;</span><br><span class="line">              q = q.next;</span><br><span class="line">          &#125;</span><br><span class="line">          k = k.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>)&#123;</span><br><span class="line">          k.next = q;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          k.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newHead.next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h2 id="倒数第K个结点"><a href="#倒数第K个结点" class="headerlink" title="倒数第K个结点"></a>倒数第K个结点</h2><p>输入一个链表，输出该链表中倒数第k个结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode p = head, q = head;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span>(c &gt; k)</span><br><span class="line">            q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &lt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode p = pHead;</span><br><span class="line">        <span class="comment">// 为每一个结点新建一个副本，紧接在原结点之后</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode nNode = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">            nNode.next = p.next;</span><br><span class="line">            p.next = nNode;</span><br><span class="line">            p = nNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = pHead;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p.next.random = p.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        RandomListNode newHead = <span class="keyword">new</span> RandomListNode(-<span class="number">1</span>), oldHead = <span class="keyword">new</span> RandomListNode(-<span class="number">1</span>), np = newHead, op = oldHead;</span><br><span class="line">        p = pHead;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分离原结点和新结点</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                op.next = p;</span><br><span class="line">                op = op.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                np.next = p;</span><br><span class="line">                np = np.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        np.next = <span class="keyword">null</span>;</span><br><span class="line">        op.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二叉搜索树转双向链表"><a href="#二叉搜索树转双向链表" class="headerlink" title="二叉搜索树转双向链表"></a>二叉搜索树转双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        convertHelper(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            root = root.left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convertHelper</span><span class="params">(TreeNode cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        convertHelper(cur.left);</span><br><span class="line">        cur.left = pre;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>)</span><br><span class="line">            pre.right = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">        convertHelper(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode sumHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = sumHead, p1 = l1, p2 = l2;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结点为空则视为0</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> || p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p1 == <span class="keyword">null</span> ? <span class="number">0</span> : p1.val;</span><br><span class="line">            <span class="keyword">int</span> y = p2 == <span class="keyword">null</span> ? <span class="number">0</span> : p2.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先看是否有进位</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum %= <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span> (p1 != <span class="keyword">null</span>)</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="keyword">null</span>)</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 链表已遍历完仍有进位</span></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
</search>
